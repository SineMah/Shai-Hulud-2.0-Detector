{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClqCA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;AEDA;AACA;AACA;AACA","sources":[".././src/cli.ts",".././src/scanner.ts","../external node-commonjs \"fs\"","../external node-commonjs \"node:child_process\"","../external node-commonjs \"node:events\"","../external node-commonjs \"node:fs\"","../external node-commonjs \"node:path\"","../external node-commonjs \"node:process\"","../external node-commonjs \"path\"",".././node_modules/commander/index.js",".././node_modules/commander/lib/argument.js",".././node_modules/commander/lib/command.js",".././node_modules/commander/lib/error.js",".././node_modules/commander/lib/help.js",".././node_modules/commander/lib/option.js",".././node_modules/commander/lib/suggestSimilar.js","../webpack/bootstrap","../webpack/runtime/compat","../webpack/before-startup","../webpack/startup","../webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commander_1 = require(\"commander\");\nconst path = __importStar(require(\"path\"));\nconst fs = __importStar(require(\"fs\"));\nconst scanner_1 = require(\"./scanner\");\nconst program = new commander_1.Command();\nprogram\n    .name('shai-hulud-detector')\n    .description('Detect Shai-Hulud 2.0 supply chain attack in npm dependencies')\n    .version('1.0.0')\n    .option('-d, --dir <path>', 'Working directory to scan', process.cwd())\n    .option('--fail-on-critical', 'Fail if critical issues are found', false)\n    .option('--fail-on-high', 'Fail if high or critical issues are found', false)\n    .option('--fail-on-any', 'Fail if any issues are found', false)\n    .option('--scan-lockfiles', 'Scan lockfiles (package-lock.json, yarn.lock)', true)\n    .option('--no-scan-lockfiles', 'Do not scan lockfiles')\n    .option('--scan-node-modules', 'Scan node_modules directory', false)\n    .option('-f, --format <format>', 'Output format (text, json, sarif)', 'text')\n    .action(async (options) => {\n    console.log('');\n    console.log('Shai-Hulud 2.0 Detector');\n    console.log('=======================');\n    // Display database info\n    const dbInfo = (0, scanner_1.getMasterPackagesInfo)();\n    console.log(`Database version: ${dbInfo.version}`);\n    console.log(`Last updated: ${dbInfo.lastUpdated}`);\n    console.log(`Total known affected packages: ${dbInfo.totalPackages}`);\n    console.log('');\n    // Resolve working directory\n    const workDir = path.resolve(options.dir);\n    console.log(`Scanning directory: ${workDir}`);\n    if (!fs.existsSync(workDir)) {\n        console.error(`Error: Working directory does not exist: ${workDir}`);\n        process.exit(1);\n    }\n    // Run the scan\n    console.log('Starting scan...');\n    // Note: runScan signature in scanner.ts is (directory: string, scanLockfiles: boolean)\n    // We might need to check if it supports scanNodeModules or if that's handled internally or missing\n    // Looking at scanner.ts, runScan is imported but I didn't see the definition in the previous view_file of scanner.ts (it was truncated?)\n    // Let's assume runScan matches what index.ts uses: runScan(workDir, inputs.scanLockfiles)\n    // Wait, index.ts uses: const summary = runScan(workDir, inputs.scanLockfiles);\n    // But inputs has scanNodeModules. Does runScan use it?\n    // I need to check runScan signature in scanner.ts again to be sure.\n    // For now I will assume it matches index.ts usage.\n    const summary = (0, scanner_1.runScan)(workDir, options.scanLockfiles);\n    // Output results based on format\n    switch (options.format) {\n        case 'json':\n            console.log('');\n            console.log('JSON Report:');\n            console.log(JSON.stringify(summary, null, 2));\n            break;\n        case 'sarif':\n            const sarifReport = (0, scanner_1.generateSarifReport)(summary);\n            const sarifPath = path.join(workDir, 'shai-hulud-results.sarif');\n            fs.writeFileSync(sarifPath, JSON.stringify(sarifReport, null, 2));\n            console.log(`SARIF report written to: ${sarifPath}`);\n            break;\n        case 'text':\n        default:\n            console.log((0, scanner_1.formatTextReport)(summary));\n            break;\n    }\n    // Determine if we should fail\n    let shouldFail = false;\n    let failReason = '';\n    const hasIssues = summary.affectedCount > 0 || summary.securityFindings.length > 0;\n    // Count critical findings from security checks\n    const criticalSecurityFindings = summary.securityFindings.filter((f) => f.severity === 'critical').length;\n    const highSecurityFindings = summary.securityFindings.filter((f) => f.severity === 'critical' || f.severity === 'high').length;\n    if (options.failOnAny && hasIssues) {\n        const issues = [];\n        if (summary.affectedCount > 0)\n            issues.push(`${summary.affectedCount} compromised package(s)`);\n        if (summary.securityFindings.length > 0)\n            issues.push(`${summary.securityFindings.length} security finding(s)`);\n        shouldFail = true;\n        failReason = issues.join(' and ');\n    }\n    else if (options.failOnCritical) {\n        const criticalPackages = summary.results.filter((r) => r.severity === 'critical').length;\n        const totalCritical = criticalPackages + criticalSecurityFindings;\n        if (totalCritical > 0) {\n            shouldFail = true;\n            failReason = `${totalCritical} critical severity issue(s) detected`;\n        }\n    }\n    else if (options.failOnHigh) {\n        const highOrAbovePackages = summary.results.filter((r) => r.severity === 'critical' || r.severity === 'high').length;\n        const totalHighOrAbove = highOrAbovePackages + highSecurityFindings;\n        if (totalHighOrAbove > 0) {\n            shouldFail = true;\n            failReason = `${totalHighOrAbove} high/critical severity issue(s) detected`;\n        }\n    }\n    if (shouldFail) {\n        console.error(`\\nFAILURE: Shai-Hulud 2.0 supply chain attack indicators detected: ${failReason}`);\n        process.exit(1);\n    }\n    else if (hasIssues) {\n        console.warn(`\\nWARNING: Issues found (${summary.affectedCount} package(s), ${summary.securityFindings.length} finding(s)) but not failing due to configuration`);\n    }\n    else {\n        console.log('\\nScan complete. No compromised packages or security issues detected.');\n    }\n});\nprogram.parse();\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZmlsZTovLy9ob21lL3NpbmUvRG9jdW1lbnRzL3NyYy9TaGFpLUh1bHVkLTIuMC1EZXRlY3Rvci9zcmMvY2xpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUNBQW9DO0FBQ3BDLDJDQUE2QjtBQUM3Qix1Q0FBeUI7QUFDekIsdUNBS21CO0FBR25CLE1BQU0sT0FBTyxHQUFHLElBQUksbUJBQU8sRUFBRSxDQUFDO0FBRTlCLE9BQU87S0FDSixJQUFJLENBQUMscUJBQXFCLENBQUM7S0FDM0IsV0FBVyxDQUFDLCtEQUErRCxDQUFDO0tBQzVFLE9BQU8sQ0FBQyxPQUFPLENBQUM7S0FDaEIsTUFBTSxDQUFDLGtCQUFrQixFQUFFLDJCQUEyQixFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztLQUN0RSxNQUFNLENBQUMsb0JBQW9CLEVBQUUsbUNBQW1DLEVBQUUsS0FBSyxDQUFDO0tBQ3hFLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSwyQ0FBMkMsRUFBRSxLQUFLLENBQUM7S0FDNUUsTUFBTSxDQUFDLGVBQWUsRUFBRSw4QkFBOEIsRUFBRSxLQUFLLENBQUM7S0FDOUQsTUFBTSxDQUFDLGtCQUFrQixFQUFFLCtDQUErQyxFQUFFLElBQUksQ0FBQztLQUNqRixNQUFNLENBQUMscUJBQXFCLEVBQUUsdUJBQXVCLENBQUM7S0FDdEQsTUFBTSxDQUFDLHFCQUFxQixFQUFFLDZCQUE2QixFQUFFLEtBQUssQ0FBQztLQUNuRSxNQUFNLENBQUMsdUJBQXVCLEVBQUUsbUNBQW1DLEVBQUUsTUFBTSxDQUFDO0tBQzVFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLEVBQUU7SUFDeEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNoQixPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDdkMsT0FB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TUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FDaEQsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLEtBQUssVUFBVSxJQUFJLENBQUMsQ0FBQyxRQUFRLEtBQUssTUFBTSxDQUMxRCxDQUFDLE1BQU0sQ0FBQztRQUNULE1BQU0sZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLENBQUM7UUFDcEUsSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUN6QixVQUFVLEdBQUcsSUFBSSxDQUFDO1lBQ2xCLFVBQVUsR0FBRyxHQUFHLGdCQUFnQiwyQ0FBMkMsQ0FBQztRQUM5RSxDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUksVUFBVSxFQUFFLENBQUM7UUFDZixPQUFPLENBQUMsS0FBSyxDQUFDLHNFQUFzRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQ2xHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEIsQ0FBQztTQUFNLElBQUksU0FBUyxFQUFFLENBQUM7UUFDckIsT0FBTyxDQUFDLElBQUksQ0FDViw0QkFBNEIsT0FBTyxDQUFDLGFBQWEsZ0JBQWdCLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLG1EQUFtRCxDQUNwSixDQUFDO0lBQ0osQ0FBQztTQUFNLENBQUM7UUFDTixPQUFPLENBQUMsR0FBRyxDQUFDLHVFQUF1RSxDQUFDLENBQUM7SUFDdkYsQ0FBQztBQUNILENBQUMsQ0FBQyxDQUFDO0FBRUwsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJ2NvbW1hbmRlcic7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHtcbiAgcnVuU2NhbixcbiAgZm9ybWF0VGV4dFJlcG9ydCxcbiAgZ2VuZXJhdGVTYXJpZlJlcG9ydCxcbiAgZ2V0TWFzdGVyUGFja2FnZXNJbmZvLFxufSBmcm9tICcuL3NjYW5uZXInO1xuaW1wb3J0IHsgU2NhblN1bW1hcnkgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgcHJvZ3JhbSA9IG5ldyBDb21tYW5kKCk7XG5cbnByb2dyYW1cbiAgLm5hbWUoJ3NoYWktaHVsdWQtZGV0ZWN0b3InKVxuICAuZGVzY3JpcHRpb24oJ0RldGVjdCBTaGFpLUh1bHVkIDIuMCBzdXBwbHkgY2hhaW4gYXR0YWNrIGluIG5wbSBkZXBlbmRlbmNpZXMnKVxuICAudmVyc2lvbignMS4wLjAnKVxuICAub3B0aW9uKCctZCwgLS1kaXIgPHBhdGg+JywgJ1dvcmtpbmcgZGlyZWN0b3J5IHRvIHNjYW4nLCBwcm9jZXNzLmN3ZCgpKVxuICAub3B0aW9uKCctLWZhaWwtb24tY3JpdGljYWwnLCAnRmFpbCBpZiBjcml0aWNhbCBpc3N1ZXMgYXJlIGZvdW5kJywgZmFsc2UpXG4gIC5vcHRpb24oJy0tZmFpbC1vbi1oaWdoJywgJ0ZhaWwgaWYgaGlnaCBvciBjcml0aWNhbCBpc3N1ZXMgYXJlIGZvdW5kJywgZmFsc2UpXG4gIC5vcHRpb24oJy0tZmFpbC1vbi1hbnknLCAnRmFpbCBpZiBhbnkgaXNzdWVzIGFyZSBmb3VuZCcsIGZhbHNlKVxuICAub3B0aW9uKCctLXNjYW4tbG9ja2ZpbGVzJywgJ1NjYW4gbG9ja2ZpbGVzIChwYWNrYWdlLWxvY2suanNvbiwgeWFybi5sb2NrKScsIHRydWUpXG4gIC5vcHRpb24oJy0tbm8tc2Nhbi1sb2NrZmlsZXMnLCAnRG8gbm90IHNjYW4gbG9ja2ZpbGVzJylcbiAgLm9wdGlvbignLS1zY2FuLW5vZGUtbW9kdWxlcycsICdTY2FuIG5vZGVfbW9kdWxlcyBkaXJlY3RvcnknLCBmYWxzZSlcbiAgLm9wdGlvbignLWYsIC0tZm9ybWF0IDxmb3JtYXQ+JywgJ091dHB1dCBmb3JtYXQgKHRleHQsIGpzb24sIHNhcmlmKScsICd0ZXh0JylcbiAgLmFjdGlvbihhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCcnKTtcbiAgICBjb25zb2xlLmxvZygnU2hhaS1IdWx1ZCAyLjAgRGV0ZWN0b3InKTtcbiAgICBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PT09PT09PT0nKTtcblxuICAgIC8vIERpc3BsYXkgZGF0YWJhc2UgaW5mb1xuICAgIGNvbnN0IGRiSW5mbyA9IGdldE1hc3RlclBhY2thZ2VzSW5mbygpO1xuICAgIGNvbnNvbGUubG9nKGBEYXRhYmFzZSB2ZXJzaW9uOiAke2RiSW5mby52ZXJzaW9ufWApO1xuICAgIGNvbnNvbGUubG9nKGBMYXN0IHVwZGF0ZWQ6ICR7ZGJJbmZvLmxhc3RVcGRhdGVkfWApO1xuICAgIGNvbnNvbGUubG9nKGBUb3RhbCBrbm93biBhZmZlY3RlZCBwYWNrYWdlczogJHtkYkluZm8udG90YWxQYWNrYWdlc31gKTtcbiAgICBjb25zb2xlLmxvZygnJyk7XG5cbiAgICAvLyBSZXNvbHZlIHdvcmtpbmcgZGlyZWN0b3J5XG4gICAgY29uc3Qgd29ya0RpciA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmRpcik7XG4gICAgY29uc29sZS5sb2coYFNjYW5uaW5nIGRpcmVjdG9yeTogJHt3b3JrRGlyfWApO1xuXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHdvcmtEaXIpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvcjogV29ya2luZyBkaXJlY3RvcnkgZG9lcyBub3QgZXhpc3Q6ICR7d29ya0Rpcn1gKTtcbiAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG5cbiAgICAvLyBSdW4gdGhlIHNjYW5cbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgc2Nhbi4uLicpO1xuICAgIC8vIE5vdGU6IHJ1blNjYW4gc2lnbmF0dXJlIGluIHNjYW5uZXIudHMgaXMgKGRpcmVjdG9yeTogc3RyaW5nLCBzY2FuTG9ja2ZpbGVzOiBib29sZWFuKVxuICAgIC8vIFdlIG1pZ2h0IG5lZWQgdG8gY2hlY2sgaWYgaXQgc3VwcG9ydHMgc2Nhbk5vZGVNb2R1bGVzIG9yIGlmIHRoYXQncyBoYW5kbGVkIGludGVybmFsbHkgb3IgbWlzc2luZ1xuICAgIC8vIExvb2tpbmcgYXQgc2Nhbm5lci50cywgcnVuU2NhbiBpcyBpbXBvcnRlZCBidXQgSSBkaWRuJ3Qgc2VlIHRoZSBkZWZpbml0aW9uIGluIHRoZSBwcmV2aW91cyB2aWV3X2ZpbGUgb2Ygc2Nhbm5lci50cyAoaXQgd2FzIHRydW5jYXRlZD8pXG4gICAgLy8gTGV0J3MgYXNzdW1lIHJ1blNjYW4gbWF0Y2hlcyB3aGF0IGluZGV4LnRzIHVzZXM6IHJ1blNjYW4od29ya0RpciwgaW5wdXRzLnNjYW5Mb2NrZmlsZXMpXG4gICAgLy8gV2FpdCwgaW5kZXgudHMgdXNlczogY29uc3Qgc3VtbWFyeSA9IHJ1blNjYW4od29ya0RpciwgaW5wdXRzLnNjYW5Mb2NrZmlsZXMpO1xuICAgIC8vIEJ1dCBpbnB1dHMgaGFzIHNjYW5Ob2RlTW9kdWxlcy4gRG9lcyBydW5TY2FuIHVzZSBpdD9cbiAgICAvLyBJIG5lZWQgdG8gY2hlY2sgcnVuU2NhbiBzaWduYXR1cmUgaW4gc2Nhbm5lci50cyBhZ2FpbiB0byBiZSBzdXJlLlxuICAgIC8vIEZvciBub3cgSSB3aWxsIGFzc3VtZSBpdCBtYXRjaGVzIGluZGV4LnRzIHVzYWdlLlxuICAgIFxuICAgIGNvbnN0IHN1bW1hcnkgPSBydW5TY2FuKHdvcmtEaXIsIG9wdGlvbnMuc2NhbkxvY2tmaWxlcyk7XG5cbiAgICAvLyBPdXRwdXQgcmVzdWx0cyBiYXNlZCBvbiBmb3JtYXRcbiAgICBzd2l0Y2ggKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgY29uc29sZS5sb2coJycpO1xuICAgICAgICBjb25zb2xlLmxvZygnSlNPTiBSZXBvcnQ6Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHN1bW1hcnksIG51bGwsIDIpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NhcmlmJzpcbiAgICAgICAgY29uc3Qgc2FyaWZSZXBvcnQgPSBnZW5lcmF0ZVNhcmlmUmVwb3J0KHN1bW1hcnkpO1xuICAgICAgICBjb25zdCBzYXJpZlBhdGggPSBwYXRoLmpvaW4od29ya0RpciwgJ3NoYWktaHVsdWQtcmVzdWx0cy5zYXJpZicpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHNhcmlmUGF0aCwgSlNPTi5zdHJpbmdpZnkoc2FyaWZSZXBvcnQsIG51bGwsIDIpKTtcbiAgICAgICAgY29uc29sZS5sb2coYFNBUklGIHJlcG9ydCB3cml0dGVuIHRvOiAke3NhcmlmUGF0aH1gKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coZm9ybWF0VGV4dFJlcG9ydChzdW1tYXJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgZmFpbFxuICAgIGxldCBzaG91bGRGYWlsID0gZmFsc2U7XG4gICAgbGV0IGZhaWxSZWFzb24gPSAnJztcbiAgICBjb25zdCBoYXNJc3N1ZXMgPSBzdW1tYXJ5LmFmZmVjdGVkQ291bnQgPiAwIHx8IHN1bW1hcnkuc2VjdXJpdHlGaW5kaW5ncy5sZW5ndGggPiAwO1xuXG4gICAgLy8gQ291bnQgY3JpdGljYWwgZmluZGluZ3MgZnJvbSBzZWN1cml0eSBjaGVja3NcbiAgICBjb25zdCBjcml0aWNhbFNlY3VyaXR5RmluZGluZ3MgPSBzdW1tYXJ5LnNlY3VyaXR5RmluZGluZ3MuZmlsdGVyKFxuICAgICAgKGYpID0+IGYuc2V2ZXJpdHkgPT09ICdjcml0aWNhbCdcbiAgICApLmxlbmd0aDtcbiAgICBjb25zdCBoaWdoU2VjdXJpdHlGaW5kaW5ncyA9IHN1bW1hcnkuc2VjdXJpdHlGaW5kaW5ncy5maWx0ZXIoXG4gICAgICAoZikgPT4gZi5zZXZlcml0eSA9PT0gJ2NyaXRpY2FsJyB8fCBmLnNldmVyaXR5ID09PSAnaGlnaCdcbiAgICApLmxlbmd0aDtcblxuICAgIGlmIChvcHRpb25zLmZhaWxPbkFueSAmJiBoYXNJc3N1ZXMpIHtcbiAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgaWYgKHN1bW1hcnkuYWZmZWN0ZWRDb3VudCA+IDApIGlzc3Vlcy5wdXNoKGAke3N1bW1hcnkuYWZmZWN0ZWRDb3VudH0gY29tcHJvbWlzZWQgcGFja2FnZShzKWApO1xuICAgICAgaWYgKHN1bW1hcnkuc2VjdXJpdHlGaW5kaW5ncy5sZW5ndGggPiAwKSBpc3N1ZXMucHVzaChgJHtzdW1tYXJ5LnNlY3VyaXR5RmluZGluZ3MubGVuZ3RofSBzZWN1cml0eSBmaW5kaW5nKHMpYCk7XG4gICAgICBzaG91bGRGYWlsID0gdHJ1ZTtcbiAgICAgIGZhaWxSZWFzb24gPSBpc3N1ZXMuam9pbignIGFuZCAnKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZmFpbE9uQ3JpdGljYWwpIHtcbiAgICAgIGNvbnN0IGNyaXRpY2FsUGFja2FnZXMgPSBzdW1tYXJ5LnJlc3VsdHMuZmlsdGVyKFxuICAgICAgICAocikgPT4gci5zZXZlcml0eSA9PT0gJ2NyaXRpY2FsJ1xuICAgICAgKS5sZW5ndGg7XG4gICAgICBjb25zdCB0b3RhbENyaXRpY2FsID0gY3JpdGljYWxQYWNrYWdlcyArIGNyaXRpY2FsU2VjdXJpdHlGaW5kaW5ncztcbiAgICAgIGlmICh0b3RhbENyaXRpY2FsID4gMCkge1xuICAgICAgICBzaG91bGRGYWlsID0gdHJ1ZTtcbiAgICAgICAgZmFpbFJlYXNvbiA9IGAke3RvdGFsQ3JpdGljYWx9IGNyaXRpY2FsIHNldmVyaXR5IGlzc3VlKHMpIGRldGVjdGVkYDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZmFpbE9uSGlnaCkge1xuICAgICAgY29uc3QgaGlnaE9yQWJvdmVQYWNrYWdlcyA9IHN1bW1hcnkucmVzdWx0cy5maWx0ZXIoXG4gICAgICAgIChyKSA9PiByLnNldmVyaXR5ID09PSAnY3JpdGljYWwnIHx8IHIuc2V2ZXJpdHkgPT09ICdoaWdoJ1xuICAgICAgKS5sZW5ndGg7XG4gICAgICBjb25zdCB0b3RhbEhpZ2hPckFib3ZlID0gaGlnaE9yQWJvdmVQYWNrYWdlcyArIGhpZ2hTZWN1cml0eUZpbmRpbmdzO1xuICAgICAgaWYgKHRvdGFsSGlnaE9yQWJvdmUgPiAwKSB7XG4gICAgICAgIHNob3VsZEZhaWwgPSB0cnVlO1xuICAgICAgICBmYWlsUmVhc29uID0gYCR7dG90YWxIaWdoT3JBYm92ZX0gaGlnaC9jcml0aWNhbCBzZXZlcml0eSBpc3N1ZShzKSBkZXRlY3RlZGA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZEZhaWwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFxcbkZBSUxVUkU6IFNoYWktSHVsdWQgMi4wIHN1cHBseSBjaGFpbiBhdHRhY2sgaW5kaWNhdG9ycyBkZXRlY3RlZDogJHtmYWlsUmVhc29ufWApO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH0gZWxzZSBpZiAoaGFzSXNzdWVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBcXG5XQVJOSU5HOiBJc3N1ZXMgZm91bmQgKCR7c3VtbWFyeS5hZmZlY3RlZENvdW50fSBwYWNrYWdlKHMpLCAke3N1bW1hcnkuc2VjdXJpdHlGaW5kaW5ncy5sZW5ndGh9IGZpbmRpbmcocykpIGJ1dCBub3QgZmFpbGluZyBkdWUgdG8gY29uZmlndXJhdGlvbmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdcXG5TY2FuIGNvbXBsZXRlLiBObyBjb21wcm9taXNlZCBwYWNrYWdlcyBvciBzZWN1cml0eSBpc3N1ZXMgZGV0ZWN0ZWQuJyk7XG4gICAgfVxuICB9KTtcblxucHJvZ3JhbS5wYXJzZSgpO1xuIl19","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isAffected = isAffected;\nexports.getPackageSeverity = getPackageSeverity;\nexports.parsePackageJson = parsePackageJson;\nexports.parsePackageLock = parsePackageLock;\nexports.parseYarnLock = parseYarnLock;\nexports.scanPackageJson = scanPackageJson;\nexports.scanPackageLock = scanPackageLock;\nexports.scanYarnLock = scanYarnLock;\nexports.findLockfiles = findLockfiles;\nexports.findPackageJsonFiles = findPackageJsonFiles;\nexports.checkSuspiciousScripts = checkSuspiciousScripts;\nexports.checkTrufflehogActivity = checkTrufflehogActivity;\nexports.checkSecretsExfiltration = checkSecretsExfiltration;\nexports.checkMaliciousRunners = checkMaliciousRunners;\nexports.checkShaiHuludRepos = checkShaiHuludRepos;\nexports.checkAffectedNamespaces = checkAffectedNamespaces;\nexports.checkSuspiciousBranches = checkSuspiciousBranches;\nexports.runScan = runScan;\nexports.generateSarifReport = generateSarifReport;\nexports.formatTextReport = formatTextReport;\nexports.getMasterPackagesInfo = getMasterPackagesInfo;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst compromised_packages_json_1 = __importDefault(require(\"../compromised-packages.json\"));\n// =============================================================================\n// SUSPICIOUS PATTERNS FOR ADVANCED DETECTION\n// =============================================================================\n// Suspicious commands in package.json scripts\nconst SUSPICIOUS_SCRIPT_PATTERNS = [\n    { pattern: /setup_bun\\.js/i, description: 'Shai-Hulud malicious setup script' },\n    { pattern: /bun_environment\\.js/i, description: 'Shai-Hulud environment script' },\n    { pattern: /\\bcurl\\s+[^|]*\\|\\s*(ba)?sh/i, description: 'Curl piped to shell execution' },\n    { pattern: /\\bwget\\s+[^|]*\\|\\s*(ba)?sh/i, description: 'Wget piped to shell execution' },\n    { pattern: /\\beval\\s*\\(/i, description: 'Eval execution (potential code injection)' },\n    { pattern: /\\beval\\s+['\"`\\$]/i, description: 'Eval with dynamic content' },\n    { pattern: /base64\\s+(--)?d(ecode)?/i, description: 'Base64 decode execution' },\n    { pattern: /\\$\\(curl/i, description: 'Command substitution with curl' },\n    { pattern: /\\$\\(wget/i, description: 'Command substitution with wget' },\n    { pattern: /node\\s+-e\\s+['\"].*?(http|eval|Buffer\\.from)/i, description: 'Inline Node.js code execution' },\n    { pattern: /npx\\s+--yes\\s+[^@\\s]+@/i, description: 'NPX auto-install of versioned package' },\n];\n// TruffleHog and credential scanning patterns\nconst TRUFFLEHOG_PATTERNS = [\n    { pattern: /trufflehog/i, description: 'TruffleHog reference detected' },\n    { pattern: /trufflesecurity/i, description: 'TruffleSecurity reference' },\n    { pattern: /credential[_-]?scan/i, description: 'Credential scanning pattern' },\n    { pattern: /secret[_-]?scan/i, description: 'Secret scanning pattern' },\n    { pattern: /--json\\s+--no-update/i, description: 'TruffleHog CLI pattern' },\n    { pattern: /github\\.com\\/trufflesecurity\\/trufflehog/i, description: 'TruffleHog GitHub download' },\n    { pattern: /releases\\/download.*trufflehog/i, description: 'TruffleHog binary download' },\n];\n// Shai-Hulud repository indicators\nconst SHAI_HULUD_REPO_PATTERNS = [\n    { pattern: /shai[-_]?hulud/i, description: 'Shai-Hulud repository name' },\n    { pattern: /the\\s+second\\s+coming/i, description: 'Shai-Hulud campaign description' },\n    { pattern: /sha1hulud/i, description: 'SHA1HULUD variant' },\n];\n// Malicious runner patterns in GitHub Actions\nconst MALICIOUS_RUNNER_PATTERNS = [\n    { pattern: /runs-on:\\s*['\"]?SHA1HULUD/i, description: 'SHA1HULUD malicious runner' },\n    { pattern: /runs-on:\\s*['\"]?self-hosted.*SHA1HULUD/i, description: 'Self-hosted SHA1HULUD runner' },\n    { pattern: /runner[_-]?name.*SHA1HULUD/i, description: 'SHA1HULUD runner reference' },\n    { pattern: /labels:.*SHA1HULUD/i, description: 'SHA1HULUD runner label' },\n];\n// Malicious workflow file patterns\nconst MALICIOUS_WORKFLOW_PATTERNS = [\n    { pattern: /formatter_.*\\.yml$/i, description: 'Shai-Hulud formatter workflow (formatter_*.yml)' },\n    { pattern: /discussion\\.ya?ml$/i, description: 'Shai-Hulud discussion workflow' },\n];\n// Medium Risk: Suspicious content patterns (webhook exfiltration)\nconst WEBHOOK_EXFIL_PATTERNS = [\n    { pattern: /webhook\\.site/i, description: 'Webhook.site exfiltration endpoint' },\n    { pattern: /bb8ca5f6-4175-45d2-b042-fc9ebb8170b7/i, description: 'Known malicious webhook UUID' },\n    { pattern: /exfiltrat/i, description: 'Exfiltration reference' },\n];\n// Known affected namespaces (for low-risk warnings)\nconst AFFECTED_NAMESPACES = [\n    '@zapier',\n    '@posthog',\n    '@asyncapi',\n    '@postman',\n    '@ensdomains',\n    '@ens',\n    '@voiceflow',\n    '@browserbase',\n    '@ctrl',\n    '@crowdstrike',\n    '@art-ws',\n    '@ngx',\n    '@nativescript-community',\n    '@oku-ui',\n];\n// Files/paths to exclude from scanning (detector's own source code)\nconst EXCLUDED_PATHS = [\n    /shai-hulud.*detector/i,\n    /\\/src\\/scanner\\.(ts|js)$/i,\n    /\\/src\\/types\\.(ts|js)$/i,\n    /\\/src\\/index\\.(ts|js)$/i,\n    /\\/dist\\/index\\.js$/i,\n    /\\/dist\\/.*\\.d\\.ts$/i,\n];\n/**\n * Check if a file path should be excluded from security scanning\n * (to prevent false positives on the detector's own source code)\n */\nfunction isExcludedPath(filePath) {\n    // Normalize path separators\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\n    // Check if this looks like the detector's own source\n    for (const pattern of EXCLUDED_PATHS) {\n        if (pattern.test(normalizedPath)) {\n            return true;\n        }\n    }\n    // Also exclude if the file contains detector identification markers\n    return false;\n}\n/**\n * Check if file content indicates this is the detector's source code\n */\nfunction isDetectorSourceCode(content) {\n    // Check for unique markers that identify this as the detector's source\n    const detectorMarkers = [\n        'SHAI-HULUD 2.0 SUPPLY CHAIN ATTACK DETECTOR',\n        'gensecaihq/Shai-Hulud-2.0-Detector',\n        'SUSPICIOUS PATTERNS FOR ADVANCED DETECTION',\n        'checkTrufflehogActivity',\n        'checkMaliciousRunners',\n    ];\n    let markerCount = 0;\n    for (const marker of detectorMarkers) {\n        if (content.includes(marker)) {\n            markerCount++;\n        }\n    }\n    // If 2+ markers found, this is likely the detector's source\n    return markerCount >= 2;\n}\nconst masterPackages = compromised_packages_json_1.default;\n// Create a Set for O(1) lookup\nconst affectedPackageNames = new Set(masterPackages.packages.map((p) => p.name));\nfunction isAffected(packageName) {\n    return affectedPackageNames.has(packageName);\n}\nfunction getPackageSeverity(packageName) {\n    const pkg = masterPackages.packages.find((p) => p.name === packageName);\n    return pkg?.severity || 'critical';\n}\nfunction parsePackageJson(filePath) {\n    try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        return JSON.parse(content);\n    }\n    catch {\n        return null;\n    }\n}\nfunction parsePackageLock(filePath) {\n    try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        return JSON.parse(content);\n    }\n    catch {\n        return null;\n    }\n}\nfunction parseYarnLock(filePath) {\n    try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        const packages = new Map();\n        // Simple yarn.lock parser - extract package names\n        const lines = content.split('\\n');\n        let currentPackage = '';\n        for (const line of lines) {\n            // Package declaration lines start without whitespace and contain @\n            if (!line.startsWith(' ') && !line.startsWith('#') && line.includes('@')) {\n                // Parse package name from lines like:\n                // \"@asyncapi/diff@^1.0.0\":\n                // \"posthog-node@^5.0.0\":\n                const match = line.match(/^\"?(@?[^@\\s\"]+)/);\n                if (match) {\n                    currentPackage = match[1];\n                }\n            }\n            // Version line\n            if (line.trim().startsWith('version') && currentPackage) {\n                const versionMatch = line.match(/version\\s+\"([^\"]+)\"/);\n                if (versionMatch) {\n                    packages.set(currentPackage, versionMatch[1]);\n                }\n            }\n        }\n        return packages;\n    }\n    catch {\n        return null;\n    }\n}\nfunction scanPackageJson(filePath, isDirect = true) {\n    const results = [];\n    const pkg = parsePackageJson(filePath);\n    if (!pkg)\n        return results;\n    const allDeps = {\n        ...pkg.dependencies,\n        ...pkg.devDependencies,\n        ...pkg.peerDependencies,\n        ...pkg.optionalDependencies,\n    };\n    for (const [name, version] of Object.entries(allDeps)) {\n        if (isAffected(name)) {\n            results.push({\n                package: name,\n                version: version || 'unknown',\n                severity: getPackageSeverity(name),\n                isDirect,\n                location: filePath,\n            });\n        }\n    }\n    return results;\n}\nfunction scanPackageLock(filePath) {\n    const results = [];\n    const lock = parsePackageLock(filePath);\n    if (!lock)\n        return results;\n    // Scan v2/v3 lockfile format (packages object)\n    if (lock.packages) {\n        for (const [pkgPath, entry] of Object.entries(lock.packages)) {\n            // Extract package name from path like \"node_modules/@asyncapi/diff\"\n            const match = pkgPath.match(/node_modules\\/(.+)$/);\n            if (match) {\n                const name = match[1];\n                if (isAffected(name)) {\n                    results.push({\n                        package: name,\n                        version: entry.version || 'unknown',\n                        severity: getPackageSeverity(name),\n                        isDirect: !pkgPath.includes('node_modules/node_modules'),\n                        location: filePath,\n                    });\n                }\n            }\n        }\n    }\n    // Scan v1 lockfile format (dependencies object)\n    if (lock.dependencies) {\n        const scanDependencies = (deps, isDirect) => {\n            for (const [name, entry] of Object.entries(deps)) {\n                if (isAffected(name)) {\n                    results.push({\n                        package: name,\n                        version: entry.version || 'unknown',\n                        severity: getPackageSeverity(name),\n                        isDirect,\n                        location: filePath,\n                    });\n                }\n                // Recursively scan nested dependencies\n                if (entry.dependencies) {\n                    scanDependencies(entry.dependencies, false);\n                }\n            }\n        };\n        scanDependencies(lock.dependencies, true);\n    }\n    return results;\n}\nfunction scanYarnLock(filePath) {\n    const results = [];\n    const packages = parseYarnLock(filePath);\n    if (!packages)\n        return results;\n    for (const [name, version] of packages.entries()) {\n        if (isAffected(name)) {\n            results.push({\n                package: name,\n                version,\n                severity: getPackageSeverity(name),\n                isDirect: false, // yarn.lock doesn't indicate direct vs transitive\n                location: filePath,\n            });\n        }\n    }\n    return results;\n}\nfunction findLockfiles(directory) {\n    const lockfiles = [];\n    const possibleFiles = [\n        'package-lock.json',\n        'yarn.lock',\n        'pnpm-lock.yaml',\n        'npm-shrinkwrap.json',\n    ];\n    // Search in root and subdirectories (for monorepos)\n    const searchDir = (dir, depth = 0) => {\n        if (depth > 5)\n            return; // Limit depth to prevent excessive recursion\n        try {\n            const entries = fs.readdirSync(dir, { withFileTypes: true });\n            for (const entry of entries) {\n                const fullPath = path.join(dir, entry.name);\n                if (entry.isFile() && possibleFiles.includes(entry.name)) {\n                    lockfiles.push(fullPath);\n                }\n                else if (entry.isDirectory() &&\n                    !entry.name.startsWith('.') &&\n                    entry.name !== 'node_modules') {\n                    searchDir(fullPath, depth + 1);\n                }\n            }\n        }\n        catch {\n            // Skip directories we can't read\n        }\n    };\n    searchDir(directory);\n    return lockfiles;\n}\nfunction findPackageJsonFiles(directory) {\n    const packageFiles = [];\n    const searchDir = (dir, depth = 0) => {\n        if (depth > 5)\n            return;\n        try {\n            const entries = fs.readdirSync(dir, { withFileTypes: true });\n            for (const entry of entries) {\n                const fullPath = path.join(dir, entry.name);\n                if (entry.isFile() && entry.name === 'package.json') {\n                    packageFiles.push(fullPath);\n                }\n                else if (entry.isDirectory() &&\n                    !entry.name.startsWith('.') &&\n                    entry.name !== 'node_modules') {\n                    searchDir(fullPath, depth + 1);\n                }\n            }\n        }\n        catch {\n            // Skip directories we can't read\n        }\n    };\n    searchDir(directory);\n    return packageFiles;\n}\n// =============================================================================\n// ADVANCED SECURITY CHECKS\n// =============================================================================\n/**\n * Check package.json scripts for suspicious patterns\n */\nfunction checkSuspiciousScripts(filePath) {\n    const findings = [];\n    const pkg = parsePackageJson(filePath);\n    if (!pkg || !pkg.scripts)\n        return findings;\n    for (const [scriptName, scriptContent] of Object.entries(pkg.scripts)) {\n        if (!scriptContent)\n            continue;\n        // Check for Shai-Hulud specific patterns (Critical)\n        if (/setup_bun\\.js/i.test(scriptContent) ||\n            /bun_environment\\.js/i.test(scriptContent)) {\n            findings.push({\n                type: 'suspicious-script',\n                severity: 'critical',\n                title: `Shai-Hulud malicious script in \"${scriptName}\"`,\n                description: `The \"${scriptName}\" script contains a reference to known Shai-Hulud malicious files. This is a strong indicator of compromise.`,\n                location: filePath,\n                evidence: `\"${scriptName}\": \"${scriptContent}\"`,\n            });\n            continue;\n        }\n        // Check all suspicious patterns\n        for (const { pattern, description } of SUSPICIOUS_SCRIPT_PATTERNS) {\n            if (pattern.test(scriptContent)) {\n                // preinstall/postinstall with suspicious commands are higher severity\n                const isCritical = ['preinstall', 'postinstall', 'prepare', 'prepublish'].includes(scriptName) &&\n                    (pattern.test(scriptContent) || /curl|wget|eval/i.test(scriptContent));\n                findings.push({\n                    type: 'suspicious-script',\n                    severity: isCritical ? 'critical' : 'high',\n                    title: `Suspicious \"${scriptName}\" script`,\n                    description: `${description}. This pattern is commonly used in supply chain attacks.`,\n                    location: filePath,\n                    evidence: `\"${scriptName}\": \"${scriptContent.substring(0, 200)}${scriptContent.length > 200 ? '...' : ''}\"`,\n                });\n                break; // Only report first match per script\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Check for TruffleHog activity and credential scanning patterns\n */\nfunction checkTrufflehogActivity(directory) {\n    const findings = [];\n    const suspiciousFiles = [];\n    const searchDir = (dir, depth = 0) => {\n        if (depth > 5)\n            return;\n        try {\n            const entries = fs.readdirSync(dir, { withFileTypes: true });\n            for (const entry of entries) {\n                const fullPath = path.join(dir, entry.name);\n                if (entry.isFile()) {\n                    // Check for TruffleHog binary or related files\n                    if (/trufflehog/i.test(entry.name) ||\n                        entry.name === 'bun_environment.js' ||\n                        entry.name === 'setup_bun.js') {\n                        suspiciousFiles.push(fullPath);\n                    }\n                    // Scan content of shell scripts and JS files\n                    if (/\\.(sh|js|ts|mjs|cjs)$/i.test(entry.name)) {\n                        // Skip excluded paths (detector's own source code)\n                        if (isExcludedPath(fullPath)) {\n                            continue;\n                        }\n                        try {\n                            const content = fs.readFileSync(fullPath, 'utf8');\n                            // Skip if this is the detector's own source code\n                            if (isDetectorSourceCode(content)) {\n                                continue;\n                            }\n                            for (const { pattern, description } of TRUFFLEHOG_PATTERNS) {\n                                if (pattern.test(content)) {\n                                    findings.push({\n                                        type: 'trufflehog-activity',\n                                        severity: 'critical',\n                                        title: `TruffleHog activity detected`,\n                                        description: `${description}. This may indicate automated credential theft as part of the Shai-Hulud attack.`,\n                                        location: fullPath,\n                                        evidence: pattern.toString(),\n                                    });\n                                    break;\n                                }\n                            }\n                            // Check for webhook exfiltration\n                            for (const { pattern, description } of WEBHOOK_EXFIL_PATTERNS) {\n                                if (pattern.test(content)) {\n                                    findings.push({\n                                        type: 'secrets-exfiltration',\n                                        severity: 'critical',\n                                        title: `Data exfiltration endpoint detected`,\n                                        description: `${description}. This endpoint may be used to exfiltrate stolen credentials.`,\n                                        location: fullPath,\n                                        evidence: pattern.toString(),\n                                    });\n                                    break;\n                                }\n                            }\n                        }\n                        catch {\n                            // Skip files we can't read\n                        }\n                    }\n                }\n                else if (entry.isDirectory() &&\n                    !entry.name.startsWith('.') &&\n                    entry.name !== 'node_modules') {\n                    searchDir(fullPath, depth + 1);\n                }\n            }\n        }\n        catch {\n            // Skip directories we can't read\n        }\n    };\n    searchDir(directory);\n    // Report suspicious files found\n    for (const file of suspiciousFiles) {\n        const fileName = path.basename(file);\n        findings.push({\n            type: 'trufflehog-activity',\n            severity: 'critical',\n            title: `Suspicious file: ${fileName}`,\n            description: `Found file \"${fileName}\" which is associated with the Shai-Hulud attack. This file may download and execute TruffleHog for credential theft.`,\n            location: file,\n        });\n    }\n    return findings;\n}\n/**\n * Check for actionsSecrets.json exfiltration files\n */\nfunction checkSecretsExfiltration(directory) {\n    const findings = [];\n    const searchDir = (dir, depth = 0) => {\n        if (depth > 5)\n            return;\n        try {\n            const entries = fs.readdirSync(dir, { withFileTypes: true });\n            for (const entry of entries) {\n                const fullPath = path.join(dir, entry.name);\n                if (entry.isFile()) {\n                    // Check for actionsSecrets.json\n                    if (entry.name === 'actionsSecrets.json') {\n                        findings.push({\n                            type: 'secrets-exfiltration',\n                            severity: 'critical',\n                            title: `Secrets exfiltration file detected`,\n                            description: `Found \"actionsSecrets.json\" which is used by the Shai-Hulud attack to store stolen credentials with double Base64 encoding before exfiltration.`,\n                            location: fullPath,\n                        });\n                    }\n                    // Check for known Shai-Hulud exfiltration/output files\n                    const knownMaliciousFiles = [\n                        'cloud.json',\n                        'contents.json',\n                        'environment.json',\n                        'truffleSecrets.json',\n                        'trufflehog_output.json',\n                    ];\n                    if (knownMaliciousFiles.includes(entry.name.toLowerCase())) {\n                        findings.push({\n                            type: 'secrets-exfiltration',\n                            severity: 'critical',\n                            title: `Shai-Hulud output file: ${entry.name}`,\n                            description: `Found \"${entry.name}\" which is a known output file from the Shai-Hulud attack containing harvested credentials or environment data.`,\n                            location: fullPath,\n                        });\n                    }\n                    // Check for large obfuscated JS files (bun_environment.js is typically 10MB+)\n                    if (entry.name === 'bun_environment.js') {\n                        try {\n                            const stats = fs.statSync(fullPath);\n                            const sizeMB = stats.size / (1024 * 1024);\n                            findings.push({\n                                type: 'trufflehog-activity',\n                                severity: 'critical',\n                                title: `Shai-Hulud payload file: bun_environment.js`,\n                                description: `Found \"bun_environment.js\" (${sizeMB.toFixed(2)}MB). This is the main obfuscated payload used by the Shai-Hulud attack to execute TruffleHog for credential theft.`,\n                                location: fullPath,\n                                evidence: `File size: ${sizeMB.toFixed(2)}MB`,\n                            });\n                        }\n                        catch {\n                            // If we can't stat, still report it\n                            findings.push({\n                                type: 'trufflehog-activity',\n                                severity: 'critical',\n                                title: `Shai-Hulud payload file: bun_environment.js`,\n                                description: `Found \"bun_environment.js\" which is the main obfuscated payload used by the Shai-Hulud attack.`,\n                                location: fullPath,\n                            });\n                        }\n                    }\n                    // Check for other suspicious JSON files that might contain secrets\n                    if (/secrets?\\.json$/i.test(entry.name) ||\n                        /credentials?\\.json$/i.test(entry.name) ||\n                        /exfil.*\\.json$/i.test(entry.name)) {\n                        try {\n                            const content = fs.readFileSync(fullPath, 'utf8');\n                            // Check if it looks like base64 encoded data\n                            if (/^[A-Za-z0-9+/=]{100,}$/m.test(content)) {\n                                findings.push({\n                                    type: 'secrets-exfiltration',\n                                    severity: 'high',\n                                    title: `Potential secrets file with encoded data`,\n                                    description: `Found \"${entry.name}\" containing what appears to be Base64 encoded data. This may be exfiltrated credentials.`,\n                                    location: fullPath,\n                                });\n                            }\n                        }\n                        catch {\n                            // Skip files we can't read\n                        }\n                    }\n                }\n                else if (entry.isDirectory() &&\n                    !entry.name.startsWith('.') &&\n                    entry.name !== 'node_modules') {\n                    searchDir(fullPath, depth + 1);\n                }\n            }\n        }\n        catch {\n            // Skip directories we can't read\n        }\n    };\n    searchDir(directory);\n    return findings;\n}\n/**\n * Check GitHub Actions workflows for malicious runners\n */\nfunction checkMaliciousRunners(directory) {\n    const findings = [];\n    const workflowDirs = [\n        path.join(directory, '.github', 'workflows'),\n        path.join(directory, '.github'),\n    ];\n    // Pattern to identify legitimate detector workflows (exclude from false positives)\n    const DETECTOR_WORKFLOW_PATTERN = /gensecaihq\\/Shai-Hulud-2\\.0-Detector|Shai-Hulud.*Detector|shai-hulud-check|shai-hulud.*security/i;\n    for (const workflowDir of workflowDirs) {\n        if (!fs.existsSync(workflowDir))\n            continue;\n        try {\n            const entries = fs.readdirSync(workflowDir, { withFileTypes: true });\n            for (const entry of entries) {\n                if (!entry.isFile())\n                    continue;\n                if (!/\\.(yml|yaml)$/i.test(entry.name))\n                    continue;\n                const fullPath = path.join(workflowDir, entry.name);\n                // Check for malicious workflow filename patterns (formatter_*.yml, discussion.yaml)\n                for (const { pattern, description } of MALICIOUS_WORKFLOW_PATTERNS) {\n                    if (pattern.test(entry.name)) {\n                        findings.push({\n                            type: 'malicious-runner',\n                            severity: 'critical',\n                            title: `Suspicious workflow file: ${entry.name}`,\n                            description: `${description}. This workflow filename matches patterns used by the Shai-Hulud attack for credential theft.`,\n                            location: fullPath,\n                            evidence: entry.name,\n                        });\n                    }\n                }\n                try {\n                    const content = fs.readFileSync(fullPath, 'utf8');\n                    // Skip workflows that are using the detector (legitimate use)\n                    if (DETECTOR_WORKFLOW_PATTERN.test(content) || DETECTOR_WORKFLOW_PATTERN.test(entry.name)) {\n                        continue;\n                    }\n                    // Check for malicious runner patterns\n                    for (const { pattern, description } of MALICIOUS_RUNNER_PATTERNS) {\n                        if (pattern.test(content)) {\n                            findings.push({\n                                type: 'malicious-runner',\n                                severity: 'critical',\n                                title: `Malicious GitHub Actions runner detected`,\n                                description: `${description}. The SHA1HULUD runner is used by the Shai-Hulud attack to execute credential theft in CI/CD environments.`,\n                                location: fullPath,\n                                evidence: pattern.toString(),\n                            });\n                        }\n                    }\n                    // Check for Shai-Hulud repo patterns in workflow (excluding detector references)\n                    for (const { pattern, description } of SHAI_HULUD_REPO_PATTERNS) {\n                        if (pattern.test(content)) {\n                            // Additional check: make sure it's not just referencing the detector\n                            const contentWithoutDetector = content.replace(/gensecaihq\\/Shai-Hulud-2\\.0-Detector[^\\s]*/gi, '');\n                            if (pattern.test(contentWithoutDetector)) {\n                                findings.push({\n                                    type: 'shai-hulud-repo',\n                                    severity: 'critical',\n                                    title: `Shai-Hulud reference in workflow`,\n                                    description: `${description}. This workflow may be configured to exfiltrate data to attacker-controlled repositories.`,\n                                    location: fullPath,\n                                    evidence: pattern.toString(),\n                                });\n                            }\n                        }\n                    }\n                }\n                catch {\n                    // Skip files we can't read\n                }\n            }\n        }\n        catch {\n            // Skip directories we can't read\n        }\n    }\n    return findings;\n}\n/**\n * Check for Shai-Hulud git repository references\n */\nfunction checkShaiHuludRepos(directory) {\n    const findings = [];\n    // Check git config\n    const gitConfigPath = path.join(directory, '.git', 'config');\n    if (fs.existsSync(gitConfigPath)) {\n        try {\n            const content = fs.readFileSync(gitConfigPath, 'utf8');\n            // Skip if this is the detector's own repository\n            if (content.includes('Shai-Hulud-2.0-Detector') ||\n                content.includes('gensecaihq')) {\n                // This is the detector's own repo, skip\n            }\n            else {\n                for (const { pattern, description } of SHAI_HULUD_REPO_PATTERNS) {\n                    if (pattern.test(content)) {\n                        findings.push({\n                            type: 'shai-hulud-repo',\n                            severity: 'critical',\n                            title: `Shai-Hulud repository reference in git config`,\n                            description: `${description}. Your repository may have been configured to push to an attacker-controlled remote.`,\n                            location: gitConfigPath,\n                        });\n                    }\n                }\n            }\n        }\n        catch {\n            // Skip if we can't read\n        }\n    }\n    // Check package.json for repository references\n    const packageJsonFiles = findPackageJsonFiles(directory);\n    for (const file of packageJsonFiles) {\n        try {\n            const content = fs.readFileSync(file, 'utf8');\n            // Skip if this is the detector's own package.json\n            if (content.includes('gensecaihq/Shai-Hulud-2.0-Detector') ||\n                content.includes('shai-hulud-detector')) {\n                continue;\n            }\n            for (const { pattern, description } of SHAI_HULUD_REPO_PATTERNS) {\n                if (pattern.test(content)) {\n                    // Make sure it's not just a reference to the detector\n                    const contentWithoutDetector = content.replace(/gensecaihq\\/Shai-Hulud-2\\.0-Detector/gi, '')\n                        .replace(/shai-hulud-detector/gi, '');\n                    if (pattern.test(contentWithoutDetector)) {\n                        findings.push({\n                            type: 'shai-hulud-repo',\n                            severity: 'high',\n                            title: `Shai-Hulud reference in package.json`,\n                            description: `${description}. Package may be configured to reference attacker infrastructure.`,\n                            location: file,\n                        });\n                    }\n                }\n            }\n        }\n        catch {\n            // Skip if we can't read\n        }\n    }\n    return findings;\n}\n/**\n * Check for packages from affected namespaces (low-risk warning)\n */\nfunction checkAffectedNamespaces(filePath) {\n    const findings = [];\n    const pkg = parsePackageJson(filePath);\n    if (!pkg)\n        return findings;\n    const allDeps = {\n        ...pkg.dependencies,\n        ...pkg.devDependencies,\n        ...pkg.peerDependencies,\n        ...pkg.optionalDependencies,\n    };\n    for (const [name, version] of Object.entries(allDeps)) {\n        // Skip if already in affected packages list\n        if (isAffected(name))\n            continue;\n        // Check if from affected namespace\n        for (const namespace of AFFECTED_NAMESPACES) {\n            if (name.startsWith(namespace + '/')) {\n                // Check for semver range patterns that could auto-update to compromised versions\n                if (version && (version.startsWith('^') || version.startsWith('~'))) {\n                    findings.push({\n                        type: 'compromised-package',\n                        severity: 'low',\n                        title: `Package from affected namespace with semver range`,\n                        description: `\"${name}\" is from the ${namespace} namespace which has known compromised packages. The version pattern \"${version}\" could auto-update to a compromised version during npm update.`,\n                        location: filePath,\n                        evidence: `\"${name}\": \"${version}\"`,\n                    });\n                }\n                break;\n            }\n        }\n    }\n    return findings;\n}\n/**\n * Check for suspicious git branches\n */\nfunction checkSuspiciousBranches(directory) {\n    const findings = [];\n    const headsPath = path.join(directory, '.git', 'refs', 'heads');\n    if (!fs.existsSync(headsPath))\n        return findings;\n    try {\n        const branches = fs.readdirSync(headsPath);\n        for (const branch of branches) {\n            for (const { pattern, description } of SHAI_HULUD_REPO_PATTERNS) {\n                if (pattern.test(branch)) {\n                    findings.push({\n                        type: 'shai-hulud-repo',\n                        severity: 'medium',\n                        title: `Suspicious git branch: ${branch}`,\n                        description: `${description}. This branch name is associated with the Shai-Hulud attack campaign.`,\n                        location: path.join(headsPath, branch),\n                    });\n                }\n            }\n        }\n    }\n    catch {\n        // Skip if we can't read\n    }\n    return findings;\n}\nfunction runScan(directory, scanLockfiles = true) {\n    const startTime = Date.now();\n    const allResults = [];\n    const allSecurityFindings = [];\n    const scannedFiles = [];\n    const seenPackages = new Set();\n    const seenFindings = new Set();\n    // Scan package.json files\n    const packageJsonFiles = findPackageJsonFiles(directory);\n    for (const file of packageJsonFiles) {\n        scannedFiles.push(file);\n        const results = scanPackageJson(file, true);\n        for (const result of results) {\n            const key = `${result.package}@${result.version}`;\n            if (!seenPackages.has(key)) {\n                seenPackages.add(key);\n                allResults.push(result);\n            }\n        }\n        // Check for suspicious scripts in package.json\n        const scriptFindings = checkSuspiciousScripts(file);\n        for (const finding of scriptFindings) {\n            const key = `${finding.type}:${finding.location}:${finding.title}`;\n            if (!seenFindings.has(key)) {\n                seenFindings.add(key);\n                allSecurityFindings.push(finding);\n            }\n        }\n        // Check for packages from affected namespaces\n        const namespaceFindings = checkAffectedNamespaces(file);\n        for (const finding of namespaceFindings) {\n            const key = `${finding.type}:${finding.location}:${finding.title}`;\n            if (!seenFindings.has(key)) {\n                seenFindings.add(key);\n                allSecurityFindings.push(finding);\n            }\n        }\n    }\n    // Scan lockfiles if enabled\n    if (scanLockfiles) {\n        const lockfiles = findLockfiles(directory);\n        for (const file of lockfiles) {\n            scannedFiles.push(file);\n            let results = [];\n            if (file.endsWith('package-lock.json') || file.endsWith('npm-shrinkwrap.json')) {\n                results = scanPackageLock(file);\n            }\n            else if (file.endsWith('yarn.lock')) {\n                results = scanYarnLock(file);\n            }\n            // TODO: Add pnpm-lock.yaml support\n            for (const result of results) {\n                const key = `${result.package}@${result.version}`;\n                if (!seenPackages.has(key)) {\n                    seenPackages.add(key);\n                    allResults.push(result);\n                }\n            }\n        }\n    }\n    // ==========================================================================\n    // ADVANCED SECURITY CHECKS\n    // ==========================================================================\n    // Check for TruffleHog activity and credential scanning\n    const trufflehogFindings = checkTrufflehogActivity(directory);\n    for (const finding of trufflehogFindings) {\n        const key = `${finding.type}:${finding.location}:${finding.title}`;\n        if (!seenFindings.has(key)) {\n            seenFindings.add(key);\n            allSecurityFindings.push(finding);\n        }\n    }\n    // Check for secrets exfiltration files (actionsSecrets.json)\n    const exfilFindings = checkSecretsExfiltration(directory);\n    for (const finding of exfilFindings) {\n        const key = `${finding.type}:${finding.location}:${finding.title}`;\n        if (!seenFindings.has(key)) {\n            seenFindings.add(key);\n            allSecurityFindings.push(finding);\n        }\n    }\n    // Check GitHub Actions workflows for malicious runners\n    const runnerFindings = checkMaliciousRunners(directory);\n    for (const finding of runnerFindings) {\n        const key = `${finding.type}:${finding.location}:${finding.title}`;\n        if (!seenFindings.has(key)) {\n            seenFindings.add(key);\n            allSecurityFindings.push(finding);\n        }\n    }\n    // Check for Shai-Hulud repository references\n    const repoFindings = checkShaiHuludRepos(directory);\n    for (const finding of repoFindings) {\n        const key = `${finding.type}:${finding.location}:${finding.title}`;\n        if (!seenFindings.has(key)) {\n            seenFindings.add(key);\n            allSecurityFindings.push(finding);\n        }\n    }\n    // Check for suspicious git branches\n    const branchFindings = checkSuspiciousBranches(directory);\n    for (const finding of branchFindings) {\n        const key = `${finding.type}:${finding.location}:${finding.title}`;\n        if (!seenFindings.has(key)) {\n            seenFindings.add(key);\n            allSecurityFindings.push(finding);\n        }\n    }\n    // Sort results by severity\n    const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n    allResults.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);\n    // Sort security findings by severity\n    allSecurityFindings.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);\n    return {\n        totalDependencies: seenPackages.size,\n        affectedCount: allResults.length,\n        cleanCount: seenPackages.size - allResults.length,\n        results: allResults,\n        securityFindings: allSecurityFindings,\n        scannedFiles,\n        scanTime: Date.now() - startTime,\n    };\n}\nfunction generateSarifReport(summary) {\n    const rules = [];\n    const results = [];\n    // Create unique rules for each affected package\n    const ruleMap = new Map();\n    let ruleIndex = 0;\n    for (const result of summary.results) {\n        let ruleId = ruleMap.get(result.package);\n        if (!ruleId) {\n            ruleId = `SHAI-HULUD-${String(++ruleIndex).padStart(4, '0')}`;\n            ruleMap.set(result.package, ruleId);\n            rules.push({\n                id: ruleId,\n                name: `CompromisedPackage_${result.package.replace(/[^a-zA-Z0-9]/g, '_')}`,\n                shortDescription: {\n                    text: `Compromised package: ${result.package}`,\n                },\n                fullDescription: {\n                    text: `The package \"${result.package}\" has been identified as compromised in the Shai-Hulud 2.0 supply chain attack. This package may contain malicious code that steals credentials and exfiltrates sensitive data.`,\n                },\n                helpUri: 'https://www.aikido.dev/blog/shai-hulud-strikes-again-hitting-zapier-ensdomains',\n                defaultConfiguration: {\n                    level: result.severity === 'critical' ? 'error' : 'warning',\n                },\n            });\n        }\n        results.push({\n            ruleId,\n            level: result.severity === 'critical' ? 'error' : 'warning',\n            message: {\n                text: `Compromised package \"${result.package}@${result.version}\" detected. This package is part of the Shai-Hulud 2.0 supply chain attack.`,\n            },\n            locations: [\n                {\n                    physicalLocation: {\n                        artifactLocation: {\n                            uri: result.location,\n                        },\n                    },\n                },\n            ],\n        });\n    }\n    // Add security findings to SARIF report\n    const findingTypeToRulePrefix = {\n        'suspicious-script': 'SCRIPT',\n        'trufflehog-activity': 'TRUFFLEHOG',\n        'shai-hulud-repo': 'REPO',\n        'secrets-exfiltration': 'EXFIL',\n        'malicious-runner': 'RUNNER',\n        'compromised-package': 'PKG',\n    };\n    for (const finding of summary.securityFindings) {\n        const prefix = findingTypeToRulePrefix[finding.type] || 'SEC';\n        const ruleKey = `${finding.type}:${finding.title}`;\n        let ruleId = ruleMap.get(ruleKey);\n        if (!ruleId) {\n            ruleId = `SHAI-${prefix}-${String(++ruleIndex).padStart(4, '0')}`;\n            ruleMap.set(ruleKey, ruleId);\n            rules.push({\n                id: ruleId,\n                name: finding.title.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 64),\n                shortDescription: {\n                    text: finding.title,\n                },\n                fullDescription: {\n                    text: finding.description,\n                },\n                helpUri: 'https://www.aikido.dev/blog/shai-hulud-strikes-again-hitting-zapier-ensdomains',\n                defaultConfiguration: {\n                    level: finding.severity === 'critical'\n                        ? 'error'\n                        : finding.severity === 'high'\n                            ? 'warning'\n                            : 'note',\n                },\n            });\n        }\n        results.push({\n            ruleId,\n            level: finding.severity === 'critical'\n                ? 'error'\n                : finding.severity === 'high'\n                    ? 'warning'\n                    : 'note',\n            message: {\n                text: `${finding.title}: ${finding.description}${finding.evidence ? `\\n\\nEvidence: ${finding.evidence}` : ''}`,\n            },\n            locations: [\n                {\n                    physicalLocation: {\n                        artifactLocation: {\n                            uri: finding.location,\n                        },\n                        ...(finding.line && {\n                            region: {\n                                startLine: finding.line,\n                            },\n                        }),\n                    },\n                },\n            ],\n        });\n    }\n    return {\n        $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',\n        version: '2.1.0',\n        runs: [\n            {\n                tool: {\n                    driver: {\n                        name: 'shai-hulud-detector',\n                        version: '1.0.0',\n                        informationUri: 'https://github.com/gensecaihq/Shai-Hulud-2.0-Detector',\n                        rules,\n                    },\n                },\n                results,\n            },\n        ],\n    };\n}\nfunction formatTextReport(summary) {\n    const lines = [];\n    const hasIssues = summary.affectedCount > 0 || summary.securityFindings.length > 0;\n    const criticalFindings = summary.securityFindings.filter(f => f.severity === 'critical');\n    const highFindings = summary.securityFindings.filter(f => f.severity === 'high');\n    const mediumFindings = summary.securityFindings.filter(f => f.severity === 'medium');\n    const lowFindings = summary.securityFindings.filter(f => f.severity === 'low');\n    lines.push('');\n    lines.push('='.repeat(70));\n    lines.push('  SHAI-HULUD 2.0 SUPPLY CHAIN ATTACK DETECTOR');\n    lines.push('='.repeat(70));\n    lines.push('');\n    if (!hasIssues) {\n        lines.push('  STATUS: CLEAN');\n        lines.push('  No compromised packages or security issues detected.');\n    }\n    else {\n        const statusParts = [];\n        if (summary.affectedCount > 0) {\n            statusParts.push(`${summary.affectedCount} compromised package(s)`);\n        }\n        if (summary.securityFindings.length > 0) {\n            statusParts.push(`${summary.securityFindings.length} security finding(s)`);\n        }\n        lines.push(`  STATUS: AFFECTED - ${statusParts.join(', ')}`);\n    }\n    // Compromised packages section\n    if (summary.affectedCount > 0) {\n        lines.push('');\n        lines.push('-'.repeat(70));\n        lines.push('  COMPROMISED PACKAGES:');\n        lines.push('-'.repeat(70));\n        for (const result of summary.results) {\n            const badge = result.severity === 'critical' ? '[CRITICAL]' : `[${result.severity.toUpperCase()}]`;\n            const direct = result.isDirect ? '(direct)' : '(transitive)';\n            lines.push(`  ${badge} ${result.package}@${result.version} ${direct}`);\n            lines.push(`         Location: ${result.location}`);\n        }\n    }\n    // Security findings section\n    if (summary.securityFindings.length > 0) {\n        lines.push('');\n        lines.push('-'.repeat(70));\n        lines.push('  SECURITY FINDINGS:');\n        lines.push('-'.repeat(70));\n        // Group by severity\n        const printFindings = (findings, label) => {\n            if (findings.length === 0)\n                return;\n            lines.push('');\n            lines.push(`  ${label} (${findings.length}):`);\n            for (const finding of findings) {\n                lines.push(`    [${finding.severity.toUpperCase()}] ${finding.title}`);\n                lines.push(`           Type: ${finding.type}`);\n                lines.push(`           Location: ${finding.location}`);\n                if (finding.evidence) {\n                    const evidence = finding.evidence.length > 80\n                        ? finding.evidence.substring(0, 77) + '...'\n                        : finding.evidence;\n                    lines.push(`           Evidence: ${evidence}`);\n                }\n                lines.push(`           ${finding.description}`);\n            }\n        };\n        printFindings(criticalFindings, 'CRITICAL');\n        printFindings(highFindings, 'HIGH');\n        printFindings(mediumFindings, 'MEDIUM');\n        printFindings(lowFindings, 'LOW');\n    }\n    lines.push('');\n    lines.push('-'.repeat(70));\n    lines.push(`  Files scanned: ${summary.scannedFiles.length}`);\n    lines.push(`  Compromised packages: ${summary.affectedCount}`);\n    lines.push(`  Security findings: ${summary.securityFindings.length}`);\n    lines.push(`  Scan time: ${summary.scanTime}ms`);\n    lines.push(`  Database version: ${masterPackages.version}`);\n    lines.push(`  Last updated: ${masterPackages.lastUpdated}`);\n    lines.push('='.repeat(70));\n    lines.push('');\n    if (hasIssues) {\n        lines.push('  IMMEDIATE ACTIONS REQUIRED:');\n        lines.push('  1. Do NOT run npm install until packages are updated');\n        lines.push('  2. Rotate all credentials (npm, GitHub, AWS, etc.)');\n        lines.push('  3. Check for unauthorized GitHub self-hosted runners named \"SHA1HULUD\"');\n        lines.push('  4. Audit GitHub repos for \"Shai-Hulud: The Second Coming\" description');\n        lines.push('  5. Check for actionsSecrets.json files containing stolen credentials');\n        lines.push('  6. Review package.json scripts for suspicious preinstall/postinstall hooks');\n        lines.push('');\n        lines.push('  For more information:');\n        lines.push('  https://www.aikido.dev/blog/shai-hulud-strikes-again-hitting-zapier-ensdomains');\n        lines.push('');\n    }\n    return lines.join('\\n');\n}\nfunction getMasterPackagesInfo() {\n    return {\n        version: masterPackages.version,\n        lastUpdated: masterPackages.lastUpdated,\n        totalPackages: masterPackages.packages.length,\n        attackInfo: masterPackages.attackInfo,\n        indicators: masterPackages.indicators,\n    };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZmlsZTovLy9ob21lL3NpbmUvRG9jdW1lbnRzL3NyYy9TaGFpLUh1bHVkLTIuMC1EZXRlY3Rvci9zcmMvc2Nhbm5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFKQSxnQ0FFQztBQUVELGdEQUtDO0FBRUQsNENBT0M7QUFFRCw0Q0FPQztBQUVELHNDQWlDQztBQUVELDBDQTZCQztBQUVELDBDQW9EQztBQUVELG9DQW1CQztBQUVELHNDQW9DQztBQUVELG9EQTZCQztBQVNELHdEQWlEQztBQUtELDBEQWtHQztBQUtELDREQXdHQztBQUtELHNEQXFGQztBQUtELGtEQWlFQztBQUtELDBEQXFDQztBQUtELDBEQTJCQztBQUVELDBCQStJQztBQUVELGtEQXlJQztBQUVELDRDQXNHQztBQUVELHNEQVFDO0FBeHdDRCx1Q0FBeUI7QUFDekIsMkNBQTZCO0FBVTdCLDZGQUE4RDtBQUU5RCxnRkFBZ0Y7QUFDaEYsNkNBQTZDO0FBQzdDLGdGQUFnRjtBQUVoRiw4Q0FBOEM7QUFDOUMsTUFBTSwwQkFBMEIsR0FBRztJQUNqQyxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxXQUFXLEVBQUUsbUNBQW1DLEVBQUU7SUFDL0UsRUFBRSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsV0FBVyxFQUFFLCtCQUErQixFQUFFO0lBQ2pGLEVBQUUsT0FBTyxFQUFFLDZCQUE2QixFQUFFLFdBQVcsRUFBRSwrQkFBK0IsRUFBRTtJQUN4RixFQUFFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxXQUFXLEVBQUUsK0JBQStCLEVBQUU7SUFDeEYsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLFdBQVcsRUFBRSwyQ0FBMkMsRUFBRTtJQUNyRixFQUFFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsMkJBQTJCLEVBQUU7SUFDMUUsRUFBRSxPQUFPLEVBQUUsMEJB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QUM7SUFFRCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUIsQ0FBQztBQUVELFNBQWdCLHFCQUFxQjtJQUNuQyxPQUFPO1FBQ0wsT0FBTyxFQUFFLGNBQWMsQ0FBQyxPQUFPO1FBQy9CLFdBQVcsRUFBRSxjQUFjLENBQUMsV0FBVztRQUN2QyxhQUFhLEVBQUUsY0FBYyxDQUFDLFFBQVEsQ0FBQyxNQUFNO1FBQzdDLFVBQVUsRUFBRSxjQUFjLENBQUMsVUFBVTtRQUNyQyxVQUFVLEVBQUUsY0FBYyxDQUFDLFVBQVU7S0FDdEMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtcbiAgTWFzdGVyUGFja2FnZXMsXG4gIFBhY2thZ2VKc29uLFxuICBQYWNrYWdlTG9jayxcbiAgU2NhblJlc3VsdCxcbiAgU2NhblN1bW1hcnksXG4gIFNhcmlmUmVzdWx0LFxuICBTZWN1cml0eUZpbmRpbmcsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IG1hc3RlclBhY2thZ2VzRGF0YSBmcm9tICcuLi9jb21wcm9taXNlZC1wYWNrYWdlcy5qc29uJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNVU1BJQ0lPVVMgUEFUVEVSTlMgRk9SIEFEVkFOQ0VEIERFVEVDVElPTlxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gU3VzcGljaW91cyBjb21tYW5kcyBpbiBwYWNrYWdlLmpzb24gc2NyaXB0c1xuY29uc3QgU1VTUElDSU9VU19TQ1JJUFRfUEFUVEVSTlMgPSBbXG4gIHsgcGF0dGVybjogL3NldHVwX2J1blxcLmpzL2ksIGRlc2NyaXB0aW9uOiAnU2hhaS1IdWx1ZCBtYWxpY2lvdXMgc2V0dXAgc2NyaXB0JyB9LFxuICB7IHBhdHRlcm46IC9idW5fZW52aXJvbm1lbnRcXC5qcy9pLCBkZXNjcmlwdGlvbjogJ1NoYWktSHVsdWQgZW52aXJvbm1lbnQgc2NyaXB0JyB9LFxuICB7IHBhdHRlcm46IC9cXGJjdXJsXFxzK1tefF0qXFx8XFxzKihiYSk/c2gvaSwgZGVzY3JpcHRpb246ICdDdXJsIHBpcGVkIHRvIHNoZWxsIGV4ZWN1dGlvbicgfSxcbiAgeyBwYXR0ZXJuOiAvXFxid2dldFxccytbXnxdKlxcfFxccyooYmEpP3NoL2ksIGRlc2NyaXB0aW9uOiAnV2dldCBwaXBlZCB0byBzaGVsbCBleGVjdXRpb24nIH0sXG4gIHsgcGF0dGVybjogL1xcYmV2YWxcXHMqXFwoL2ksIGRlc2NyaXB0aW9uOiAnRXZhbCBleGVjdXRpb24gKHBvdGVudGlhbCBjb2RlIGluamVjdGlvbiknIH0sXG4gIHsgcGF0dGVybjogL1xcYmV2YWxcXHMrWydcImBcXCRdL2ksIGRlc2NyaXB0aW9uOiAnRXZhbCB3aXRoIGR5bmFtaWMgY29udGVudCcgfSxcbiAgeyBwYXR0ZXJuOiAvYmFzZTY0XFxzKygtLSk/ZChlY29kZSk/L2ksIGRlc2NyaXB0aW9uOiAnQmFzZTY0IGRlY29kZSBleGVjdXRpb24nIH0sXG4gIHsgcGF0dGVybjogL1xcJFxcKGN1cmwvaSwgZGVzY3JpcHRpb246ICdDb21tYW5kIHN1YnN0aXR1dGlvbiB3aXRoIGN1cmwnIH0sXG4gIHsgcGF0dGVybjogL1xcJFxcKHdnZXQvaSwgZGVzY3JpcHRpb246ICdDb21tYW5kIHN1YnN0aXR1dGlvbiB3aXRoIHdnZXQnIH0sXG4gIHsgcGF0dGVybjogL25vZGVcXHMrLWVcXHMrWydcIl0uKj8oaHR0cHxldmFsfEJ1ZmZlclxcLmZyb20pL2ksIGRlc2NyaXB0aW9uOiAnSW5saW5lIE5vZGUuanMgY29kZSBleGVjdXRpb24nIH0sXG4gIHsgcGF0dGVybjogL25weFxccystLXllc1xccytbXkBcXHNdK0AvaSwgZGVzY3JpcHRpb246ICdOUFggYXV0by1pbnN0YWxsIG9mIHZlcnNpb25lZCBwYWNrYWdlJyB9LFxuXTtcblxuLy8gVHJ1ZmZsZUhvZyBhbmQgY3JlZGVudGlhbCBzY2FubmluZyBwYXR0ZXJuc1xuY29uc3QgVFJVRkZMRUhPR19QQVRURVJOUyA9IFtcbiAgeyBwYXR0ZXJuOiAvdHJ1ZmZsZWhvZy9pLCBkZXNjcmlwdGlvbjogJ1RydWZmbGVIb2cgcmVmZXJlbmNlIGRldGVjdGVkJyB9LFxuICB7IHBhdHRlcm46IC90cnVmZmxlc2VjdXJpdHkvaSwgZGVzY3JpcHRpb246ICdUcnVmZmxlU2VjdXJpdHkgcmVmZXJlbmNlJyB9LFxuICB7IHBhdHRlcm46IC9jcmVkZW50aWFsW18tXT9zY2FuL2ksIGRlc2NyaXB0aW9uOiAnQ3JlZGVudGlhbCBzY2FubmluZyBwYXR0ZXJuJyB9LFxuICB7IHBhdHRlcm46IC9zZWNyZXRbXy1dP3NjYW4vaSwgZGVzY3JpcHRpb246ICdTZWNyZXQgc2Nhbm5pbmcgcGF0dGVybicgfSxcbiAgeyBwYXR0ZXJuOiAvLS1qc29uXFxzKy0tbm8tdXBkYXRlL2ksIGRlc2NyaXB0aW9uOiAnVHJ1ZmZsZUhvZyBDTEkgcGF0dGVybicgfSxcbiAgeyBwYXR0ZXJuOiAvZ2l0aHViXFwuY29tXFwvdHJ1ZmZsZXNlY3VyaXR5XFwvdHJ1ZmZsZWhvZy9pLCBkZXNjcmlwdGlvbjogJ1RydWZmbGVIb2cgR2l0SHViIGRvd25sb2FkJyB9LFxuICB7IHBhdHRlcm46IC9yZWxlYXNlc1xcL2Rvd25sb2FkLip0cnVmZmxlaG9nL2ksIGRlc2NyaXB0aW9uOiAnVHJ1ZmZsZUhvZyBiaW5hcnkgZG93bmxvYWQnIH0sXG5dO1xuXG4vLyBTaGFpLUh1bHVkIHJlcG9zaXRvcnkgaW5kaWNhdG9yc1xuY29uc3QgU0hBSV9IVUxVRF9SRVBPX1BBVFRFUk5TID0gW1xuICB7IHBhdHRlcm46IC9zaGFpWy1fXT9odWx1ZC9pLCBkZXNjcmlwdGlvbjogJ1NoYWktSHVsdWQgcmVwb3NpdG9yeSBuYW1lJyB9LFxuICB7IHBhdHRlcm46IC90aGVcXHMrc2Vjb25kXFxzK2NvbWluZy9pLCBkZXNjcmlwdGlvbjogJ1NoYWktSHVsdWQgY2FtcGFpZ24gZGVzY3JpcHRpb24nIH0sXG4gIHsgcGF0dGVybjogL3NoYTFodWx1ZC9pLCBkZXNjcmlwdGlvbjogJ1NIQTFIVUxVRCB2YXJpYW50JyB9LFxuXTtcblxuLy8gTWFsaWNpb3VzIHJ1bm5lciBwYXR0ZXJucyBpbiBHaXRIdWIgQWN0aW9uc1xuY29uc3QgTUFMSUNJT1VTX1JVTk5FUl9QQVRURVJOUyA9IFtcbiAgeyBwYXR0ZXJuOiAvcnVucy1vbjpcXHMqWydcIl0/U0hBMUhVTFVEL2ksIGRlc2NyaXB0aW9uOiAnU0hBMUhVTFVEIG1hbGljaW91cyBydW5uZXInIH0sXG4gIHsgcGF0dGVybjogL3J1bnMtb246XFxzKlsnXCJdP3NlbGYtaG9zdGVkLipTSEExSFVMVUQvaSwgZGVzY3JpcHRpb246ICdTZWxmLWhvc3RlZCBTSEExSFVMVUQgcnVubmVyJyB9LFxuICB7IHBhdHRlcm46IC9ydW5uZXJbXy1dP25hbWUuKlNIQTFIVUxVRC9pLCBkZXNjcmlwdGlvbjogJ1NIQTFIVUxVRCBydW5uZXIgcmVmZXJlbmNlJyB9LFxuICB7IHBhdHRlcm46IC9sYWJlbHM6LipTSEExSFVMVUQvaSwgZGVzY3JpcHRpb246ICdTSEExSFVMVUQgcnVubmVyIGxhYmVsJyB9LFxuXTtcblxuLy8gTWFsaWNpb3VzIHdvcmtmbG93IGZpbGUgcGF0dGVybnNcbmNvbnN0IE1BTElDSU9VU19XT1JLRkxPV19QQVRURVJOUyA9IFtcbiAgeyBwYXR0ZXJuOiAvZm9ybWF0dGVyXy4qXFwueW1sJC9pLCBkZXNjcmlwdGlvbjogJ1NoYWktSHVsdWQgZm9ybWF0dGVyIHdvcmtmbG93IChmb3JtYXR0ZXJfKi55bWwpJyB9LFxuICB7IHBhdHRlcm46IC9kaXNjdXNzaW9uXFwueWE/bWwkL2ksIGRlc2NyaXB0aW9uOiAnU2hhaS1IdWx1ZCBkaXNjdXNzaW9uIHdvcmtmbG93JyB9LFxuXTtcblxuLy8gTWVkaXVtIFJpc2s6IFN1c3BpY2lvdXMgY29udGVudCBwYXR0ZXJucyAod2ViaG9vayBleGZpbHRyYXRpb24pXG5jb25zdCBXRUJIT09LX0VYRklMX1BBVFRFUk5TID0gW1xuICB7IHBhdHRlcm46IC93ZWJob29rXFwuc2l0ZS9pLCBkZXNjcmlwdGlvbjogJ1dlYmhvb2suc2l0ZSBleGZpbHRyYXRpb24gZW5kcG9pbnQnIH0sXG4gIHsgcGF0dGVybjogL2JiOGNhNWY2LTQxNzUtNDVkMi1iMDQyLWZjOWViYjgxNzBiNy9pLCBkZXNjcmlwdGlvbjogJ0tub3duIG1hbGljaW91cyB3ZWJob29rIFVVSUQnIH0sXG4gIHsgcGF0dGVybjogL2V4ZmlsdHJhdC9pLCBkZXNjcmlwdGlvbjogJ0V4ZmlsdHJhdGlvbiByZWZlcmVuY2UnIH0sXG5dO1xuXG4vLyBLbm93biBhZmZlY3RlZCBuYW1lc3BhY2VzIChmb3IgbG93LXJpc2sgd2FybmluZ3MpXG5jb25zdCBBRkZFQ1RFRF9OQU1FU1BBQ0VTID0gW1xuICAnQHphcGllcicsXG4gICdAcG9zdGhvZycsXG4gICdAYXN5bmNhcGknLFxuICAnQHBvc3RtYW4nLFxuICAnQGVuc2RvbWFpbnMnLFxuICAnQGVucycsXG4gICdAdm9pY2VmbG93JyxcbiAgJ0Bicm93c2VyYmFzZScsXG4gICdAY3RybCcsXG4gICdAY3Jvd2RzdHJpa2UnLFxuICAnQGFydC13cycsXG4gICdAbmd4JyxcbiAgJ0BuYXRpdmVzY3JpcHQtY29tbXVuaXR5JyxcbiAgJ0Bva3UtdWknLFxuXTtcblxuLy8gRmlsZXMvcGF0aHMgdG8gZXhjbHVkZSBmcm9tIHNjYW5uaW5nIChkZXRlY3RvcidzIG93biBzb3VyY2UgY29kZSlcbmNvbnN0IEVYQ0xVREVEX1BBVEhTID0gW1xuICAvc2hhaS1odWx1ZC4qZGV0ZWN0b3IvaSxcbiAgL1xcL3NyY1xcL3NjYW5uZXJcXC4odHN8anMpJC9pLFxuICAvXFwvc3JjXFwvdHlwZXNcXC4odHN8anMpJC9pLFxuICAvXFwvc3JjXFwvaW5kZXhcXC4odHN8anMpJC9pLFxuICAvXFwvZGlzdFxcL2luZGV4XFwuanMkL2ksXG4gIC9cXC9kaXN0XFwvLipcXC5kXFwudHMkL2ksXG5dO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgZmlsZSBwYXRoIHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIHNlY3VyaXR5IHNjYW5uaW5nXG4gKiAodG8gcHJldmVudCBmYWxzZSBwb3NpdGl2ZXMgb24gdGhlIGRldGVjdG9yJ3Mgb3duIHNvdXJjZSBjb2RlKVxuICovXG5mdW5jdGlvbiBpc0V4Y2x1ZGVkUGF0aChmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIE5vcm1hbGl6ZSBwYXRoIHNlcGFyYXRvcnNcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBmaWxlUGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBsb29rcyBsaWtlIHRoZSBkZXRlY3RvcidzIG93biBzb3VyY2VcbiAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIEVYQ0xVREVEX1BBVEhTKSB7XG4gICAgaWYgKHBhdHRlcm4udGVzdChub3JtYWxpemVkUGF0aCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFsc28gZXhjbHVkZSBpZiB0aGUgZmlsZSBjb250YWlucyBkZXRlY3RvciBpZGVudGlmaWNhdGlvbiBtYXJrZXJzXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIGNvbnRlbnQgaW5kaWNhdGVzIHRoaXMgaXMgdGhlIGRldGVjdG9yJ3Mgc291cmNlIGNvZGVcbiAqL1xuZnVuY3Rpb24gaXNEZXRlY3RvclNvdXJjZUNvZGUoY29udGVudDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIENoZWNrIGZvciB1bmlxdWUgbWFya2VycyB0aGF0IGlkZW50aWZ5IHRoaXMgYXMgdGhlIGRldGVjdG9yJ3Mgc291cmNlXG4gIGNvbnN0IGRldGVjdG9yTWFya2VycyA9IFtcbiAgICAnU0hBSS1IVUxVRCAyLjAgU1VQUExZIENIQUlOIEFUVEFDSyBERVRFQ1RPUicsXG4gICAgJ2dlbnNlY2FpaHEvU2hhaS1IdWx1ZC0yLjAtRGV0ZWN0b3InLFxuICAgICdTVVNQSUNJT1VTIFBBVFRFUk5TIEZPUiBBRFZBTkNFRCBERVRFQ1RJT04nLFxuICAgICdjaGVja1RydWZmbGVob2dBY3Rpdml0eScsXG4gICAgJ2NoZWNrTWFsaWNpb3VzUnVubmVycycsXG4gIF07XG5cbiAgbGV0IG1hcmtlckNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBtYXJrZXIgb2YgZGV0ZWN0b3JNYXJrZXJzKSB7XG4gICAgaWYgKGNvbnRlbnQuaW5jbHVkZXMobWFya2VyKSkge1xuICAgICAgbWFya2VyQ291bnQrKztcbiAgICB9XG4gIH1cblxuICAvLyBJZiAyKyBtYXJrZXJzIGZvdW5kLCB0aGlzIGlzIGxpa2VseSB0aGUgZGV0ZWN0b3IncyBzb3VyY2VcbiAgcmV0dXJuIG1hcmtlckNvdW50ID49IDI7XG59XG5cbmNvbnN0IG1hc3RlclBhY2thZ2VzOiBNYXN0ZXJQYWNrYWdlcyA9IG1hc3RlclBhY2thZ2VzRGF0YSBhcyBNYXN0ZXJQYWNrYWdlcztcblxuLy8gQ3JlYXRlIGEgU2V0IGZvciBPKDEpIGxvb2t1cFxuY29uc3QgYWZmZWN0ZWRQYWNrYWdlTmFtZXMgPSBuZXcgU2V0KFxuICBtYXN0ZXJQYWNrYWdlcy5wYWNrYWdlcy5tYXAoKHApID0+IHAubmFtZSlcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FmZmVjdGVkKHBhY2thZ2VOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGFmZmVjdGVkUGFja2FnZU5hbWVzLmhhcyhwYWNrYWdlTmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrYWdlU2V2ZXJpdHkoXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmdcbik6ICdjcml0aWNhbCcgfCAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnIHtcbiAgY29uc3QgcGtnID0gbWFzdGVyUGFja2FnZXMucGFja2FnZXMuZmluZCgocCkgPT4gcC5uYW1lID09PSBwYWNrYWdlTmFtZSk7XG4gIHJldHVybiBwa2c/LnNldmVyaXR5IHx8ICdjcml0aWNhbCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhY2thZ2VKc29uKGZpbGVQYXRoOiBzdHJpbmcpOiBQYWNrYWdlSnNvbiB8IG51bGwge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCkgYXMgUGFja2FnZUpzb247XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVBhY2thZ2VMb2NrKGZpbGVQYXRoOiBzdHJpbmcpOiBQYWNrYWdlTG9jayB8IG51bGwge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCkgYXMgUGFja2FnZUxvY2s7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVlhcm5Mb2NrKGZpbGVQYXRoOiBzdHJpbmcpOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHwgbnVsbCB7XG4gIHRyeSB7XG4gICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICBjb25zdCBwYWNrYWdlcyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cbiAgICAvLyBTaW1wbGUgeWFybi5sb2NrIHBhcnNlciAtIGV4dHJhY3QgcGFja2FnZSBuYW1lc1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgbGV0IGN1cnJlbnRQYWNrYWdlID0gJyc7XG5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIC8vIFBhY2thZ2UgZGVjbGFyYXRpb24gbGluZXMgc3RhcnQgd2l0aG91dCB3aGl0ZXNwYWNlIGFuZCBjb250YWluIEBcbiAgICAgIGlmICghbGluZS5zdGFydHNXaXRoKCcgJykgJiYgIWxpbmUuc3RhcnRzV2l0aCgnIycpICYmIGxpbmUuaW5jbHVkZXMoJ0AnKSkge1xuICAgICAgICAvLyBQYXJzZSBwYWNrYWdlIG5hbWUgZnJvbSBsaW5lcyBsaWtlOlxuICAgICAgICAvLyBcIkBhc3luY2FwaS9kaWZmQF4xLjAuMFwiOlxuICAgICAgICAvLyBcInBvc3Rob2ctbm9kZUBeNS4wLjBcIjpcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eXCI/KEA/W15AXFxzXCJdKykvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgY3VycmVudFBhY2thZ2UgPSBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVmVyc2lvbiBsaW5lXG4gICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aCgndmVyc2lvbicpICYmIGN1cnJlbnRQYWNrYWdlKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IGxpbmUubWF0Y2goL3ZlcnNpb25cXHMrXCIoW15cIl0rKVwiLyk7XG4gICAgICAgIGlmICh2ZXJzaW9uTWF0Y2gpIHtcbiAgICAgICAgICBwYWNrYWdlcy5zZXQoY3VycmVudFBhY2thZ2UsIHZlcnNpb25NYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFja2FnZXM7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FuUGFja2FnZUpzb24oXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIGlzRGlyZWN0OiBib29sZWFuID0gdHJ1ZVxuKTogU2NhblJlc3VsdFtdIHtcbiAgY29uc3QgcmVzdWx0czogU2NhblJlc3VsdFtdID0gW107XG4gIGNvbnN0IHBrZyA9IHBhcnNlUGFja2FnZUpzb24oZmlsZVBhdGgpO1xuXG4gIGlmICghcGtnKSByZXR1cm4gcmVzdWx0cztcblxuICBjb25zdCBhbGxEZXBzID0ge1xuICAgIC4uLnBrZy5kZXBlbmRlbmNpZXMsXG4gICAgLi4ucGtnLmRldkRlcGVuZGVuY2llcyxcbiAgICAuLi5wa2cucGVlckRlcGVuZGVuY2llcyxcbiAgICAuLi5wa2cub3B0aW9uYWxEZXBlbmRlbmNpZXMsXG4gIH07XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgdmVyc2lvbl0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRGVwcykpIHtcbiAgICBpZiAoaXNBZmZlY3RlZChuYW1lKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgcGFja2FnZTogbmFtZSxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbiB8fCAndW5rbm93bicsXG4gICAgICAgIHNldmVyaXR5OiBnZXRQYWNrYWdlU2V2ZXJpdHkobmFtZSksXG4gICAgICAgIGlzRGlyZWN0LFxuICAgICAgICBsb2NhdGlvbjogZmlsZVBhdGgsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYW5QYWNrYWdlTG9jayhmaWxlUGF0aDogc3RyaW5nKTogU2NhblJlc3VsdFtdIHtcbiAgY29uc3QgcmVzdWx0czogU2NhblJlc3VsdFtdID0gW107XG4gIGNvbnN0IGxvY2sgPSBwYXJzZVBhY2thZ2VMb2NrKGZpbGVQYXRoKTtcblxuICBpZiAoIWxvY2spIHJldHVybiByZXN1bHRzO1xuXG4gIC8vIFNjYW4gdjIvdjMgbG9ja2ZpbGUgZm9ybWF0IChwYWNrYWdlcyBvYmplY3QpXG4gIGlmIChsb2NrLnBhY2thZ2VzKSB7XG4gICAgZm9yIChjb25zdCBbcGtnUGF0aCwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKGxvY2sucGFja2FnZXMpKSB7XG4gICAgICAvLyBFeHRyYWN0IHBhY2thZ2UgbmFtZSBmcm9tIHBhdGggbGlrZSBcIm5vZGVfbW9kdWxlcy9AYXN5bmNhcGkvZGlmZlwiXG4gICAgICBjb25zdCBtYXRjaCA9IHBrZ1BhdGgubWF0Y2goL25vZGVfbW9kdWxlc1xcLyguKykkLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICBpZiAoaXNBZmZlY3RlZChuYW1lKSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBwYWNrYWdlOiBuYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogZW50cnkudmVyc2lvbiB8fCAndW5rbm93bicsXG4gICAgICAgICAgICBzZXZlcml0eTogZ2V0UGFja2FnZVNldmVyaXR5KG5hbWUpLFxuICAgICAgICAgICAgaXNEaXJlY3Q6ICFwa2dQYXRoLmluY2x1ZGVzKCdub2RlX21vZHVsZXMvbm9kZV9tb2R1bGVzJyksXG4gICAgICAgICAgICBsb2NhdGlvbjogZmlsZVBhdGgsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTY2FuIHYxIGxvY2tmaWxlIGZvcm1hdCAoZGVwZW5kZW5jaWVzIG9iamVjdClcbiAgaWYgKGxvY2suZGVwZW5kZW5jaWVzKSB7XG4gICAgY29uc3Qgc2NhbkRlcGVuZGVuY2llcyA9IChcbiAgICAgIGRlcHM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICBpc0RpcmVjdDogYm9vbGVhblxuICAgICkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKGRlcHMpKSB7XG4gICAgICAgIGlmIChpc0FmZmVjdGVkKG5hbWUpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIHBhY2thZ2U6IG5hbWUsXG4gICAgICAgICAgICB2ZXJzaW9uOiBlbnRyeS52ZXJzaW9uIHx8ICd1bmtub3duJyxcbiAgICAgICAgICAgIHNldmVyaXR5OiBnZXRQYWNrYWdlU2V2ZXJpdHkobmFtZSksXG4gICAgICAgICAgICBpc0RpcmVjdCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBmaWxlUGF0aCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBzY2FuIG5lc3RlZCBkZXBlbmRlbmNpZXNcbiAgICAgICAgaWYgKGVudHJ5LmRlcGVuZGVuY2llcykge1xuICAgICAgICAgIHNjYW5EZXBlbmRlbmNpZXMoZW50cnkuZGVwZW5kZW5jaWVzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHNjYW5EZXBlbmRlbmNpZXMobG9jay5kZXBlbmRlbmNpZXMsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FuWWFybkxvY2soZmlsZVBhdGg6IHN0cmluZyk6IFNjYW5SZXN1bHRbXSB7XG4gIGNvbnN0IHJlc3VsdHM6IFNjYW5SZXN1bHRbXSA9IFtdO1xuICBjb25zdCBwYWNrYWdlcyA9IHBhcnNlWWFybkxvY2soZmlsZVBhdGgpO1xuXG4gIGlmICghcGFja2FnZXMpIHJldHVybiByZXN1bHRzO1xuXG4gIGZvciAoY29uc3QgW25hbWUsIHZlcnNpb25dIG9mIHBhY2thZ2VzLmVudHJpZXMoKSkge1xuICAgIGlmIChpc0FmZmVjdGVkKG5hbWUpKSB7XG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBwYWNrYWdlOiBuYW1lLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBzZXZlcml0eTogZ2V0UGFja2FnZVNldmVyaXR5KG5hbWUpLFxuICAgICAgICBpc0RpcmVjdDogZmFsc2UsIC8vIHlhcm4ubG9jayBkb2Vzbid0IGluZGljYXRlIGRpcmVjdCB2cyB0cmFuc2l0aXZlXG4gICAgICAgIGxvY2F0aW9uOiBmaWxlUGF0aCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZExvY2tmaWxlcyhkaXJlY3Rvcnk6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgbG9ja2ZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBwb3NzaWJsZUZpbGVzID0gW1xuICAgICdwYWNrYWdlLWxvY2suanNvbicsXG4gICAgJ3lhcm4ubG9jaycsXG4gICAgJ3BucG0tbG9jay55YW1sJyxcbiAgICAnbnBtLXNocmlua3dyYXAuanNvbicsXG4gIF07XG5cbiAgLy8gU2VhcmNoIGluIHJvb3QgYW5kIHN1YmRpcmVjdG9yaWVzIChmb3IgbW9ub3JlcG9zKVxuICBjb25zdCBzZWFyY2hEaXIgPSAoZGlyOiBzdHJpbmcsIGRlcHRoOiBudW1iZXIgPSAwKSA9PiB7XG4gICAgaWYgKGRlcHRoID4gNSkgcmV0dXJuOyAvLyBMaW1pdCBkZXB0aCB0byBwcmV2ZW50IGV4Y2Vzc2l2ZSByZWN1cnNpb25cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZnMucmVhZGRpclN5bmMoZGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIGVudHJ5Lm5hbWUpO1xuXG4gICAgICAgIGlmIChlbnRyeS5pc0ZpbGUoKSAmJiBwb3NzaWJsZUZpbGVzLmluY2x1ZGVzKGVudHJ5Lm5hbWUpKSB7XG4gICAgICAgICAgbG9ja2ZpbGVzLnB1c2goZnVsbFBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGVudHJ5LmlzRGlyZWN0b3J5KCkgJiZcbiAgICAgICAgICAhZW50cnkubmFtZS5zdGFydHNXaXRoKCcuJykgJiZcbiAgICAgICAgICBlbnRyeS5uYW1lICE9PSAnbm9kZV9tb2R1bGVzJ1xuICAgICAgICApIHtcbiAgICAgICAgICBzZWFyY2hEaXIoZnVsbFBhdGgsIGRlcHRoICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIFNraXAgZGlyZWN0b3JpZXMgd2UgY2FuJ3QgcmVhZFxuICAgIH1cbiAgfTtcblxuICBzZWFyY2hEaXIoZGlyZWN0b3J5KTtcbiAgcmV0dXJuIGxvY2tmaWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYWNrYWdlSnNvbkZpbGVzKGRpcmVjdG9yeTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBwYWNrYWdlRmlsZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3Qgc2VhcmNoRGlyID0gKGRpcjogc3RyaW5nLCBkZXB0aDogbnVtYmVyID0gMCkgPT4ge1xuICAgIGlmIChkZXB0aCA+IDUpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZnMucmVhZGRpclN5bmMoZGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIGVudHJ5Lm5hbWUpO1xuXG4gICAgICAgIGlmIChlbnRyeS5pc0ZpbGUoKSAmJiBlbnRyeS5uYW1lID09PSAncGFja2FnZS5qc29uJykge1xuICAgICAgICAgIHBhY2thZ2VGaWxlcy5wdXNoKGZ1bGxQYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBlbnRyeS5pc0RpcmVjdG9yeSgpICYmXG4gICAgICAgICAgIWVudHJ5Lm5hbWUuc3RhcnRzV2l0aCgnLicpICYmXG4gICAgICAgICAgZW50cnkubmFtZSAhPT0gJ25vZGVfbW9kdWxlcydcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2VhcmNoRGlyKGZ1bGxQYXRoLCBkZXB0aCArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTa2lwIGRpcmVjdG9yaWVzIHdlIGNhbid0IHJlYWRcbiAgICB9XG4gIH07XG5cbiAgc2VhcmNoRGlyKGRpcmVjdG9yeSk7XG4gIHJldHVybiBwYWNrYWdlRmlsZXM7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBBRFZBTkNFRCBTRUNVUklUWSBDSEVDS1Ncbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ2hlY2sgcGFja2FnZS5qc29uIHNjcmlwdHMgZm9yIHN1c3BpY2lvdXMgcGF0dGVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrU3VzcGljaW91c1NjcmlwdHMoZmlsZVBhdGg6IHN0cmluZyk6IFNlY3VyaXR5RmluZGluZ1tdIHtcbiAgY29uc3QgZmluZGluZ3M6IFNlY3VyaXR5RmluZGluZ1tdID0gW107XG4gIGNvbnN0IHBrZyA9IHBhcnNlUGFja2FnZUpzb24oZmlsZVBhdGgpO1xuXG4gIGlmICghcGtnIHx8ICFwa2cuc2NyaXB0cykgcmV0dXJuIGZpbmRpbmdzO1xuXG4gIGZvciAoY29uc3QgW3NjcmlwdE5hbWUsIHNjcmlwdENvbnRlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHBrZy5zY3JpcHRzKSkge1xuICAgIGlmICghc2NyaXB0Q29udGVudCkgY29udGludWU7XG5cbiAgICAvLyBDaGVjayBmb3IgU2hhaS1IdWx1ZCBzcGVjaWZpYyBwYXR0ZXJucyAoQ3JpdGljYWwpXG4gICAgaWYgKFxuICAgICAgL3NldHVwX2J1blxcLmpzL2kudGVzdChzY3JpcHRDb250ZW50KSB8fFxuICAgICAgL2J1bl9lbnZpcm9ubWVudFxcLmpzL2kudGVzdChzY3JpcHRDb250ZW50KVxuICAgICkge1xuICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgIHR5cGU6ICdzdXNwaWNpb3VzLXNjcmlwdCcsXG4gICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICB0aXRsZTogYFNoYWktSHVsdWQgbWFsaWNpb3VzIHNjcmlwdCBpbiBcIiR7c2NyaXB0TmFtZX1cImAsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgVGhlIFwiJHtzY3JpcHROYW1lfVwiIHNjcmlwdCBjb250YWlucyBhIHJlZmVyZW5jZSB0byBrbm93biBTaGFpLUh1bHVkIG1hbGljaW91cyBmaWxlcy4gVGhpcyBpcyBhIHN0cm9uZyBpbmRpY2F0b3Igb2YgY29tcHJvbWlzZS5gLFxuICAgICAgICBsb2NhdGlvbjogZmlsZVBhdGgsXG4gICAgICAgIGV2aWRlbmNlOiBgXCIke3NjcmlwdE5hbWV9XCI6IFwiJHtzY3JpcHRDb250ZW50fVwiYCxcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWxsIHN1c3BpY2lvdXMgcGF0dGVybnNcbiAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgZGVzY3JpcHRpb24gfSBvZiBTVVNQSUNJT1VTX1NDUklQVF9QQVRURVJOUykge1xuICAgICAgaWYgKHBhdHRlcm4udGVzdChzY3JpcHRDb250ZW50KSkge1xuICAgICAgICAvLyBwcmVpbnN0YWxsL3Bvc3RpbnN0YWxsIHdpdGggc3VzcGljaW91cyBjb21tYW5kcyBhcmUgaGlnaGVyIHNldmVyaXR5XG4gICAgICAgIGNvbnN0IGlzQ3JpdGljYWwgPVxuICAgICAgICAgIFsncHJlaW5zdGFsbCcsICdwb3N0aW5zdGFsbCcsICdwcmVwYXJlJywgJ3ByZXB1Ymxpc2gnXS5pbmNsdWRlcyhcbiAgICAgICAgICAgIHNjcmlwdE5hbWVcbiAgICAgICAgICApICYmXG4gICAgICAgICAgKHBhdHRlcm4udGVzdChzY3JpcHRDb250ZW50KSB8fCAvY3VybHx3Z2V0fGV2YWwvaS50ZXN0KHNjcmlwdENvbnRlbnQpKTtcblxuICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc3VzcGljaW91cy1zY3JpcHQnLFxuICAgICAgICAgIHNldmVyaXR5OiBpc0NyaXRpY2FsID8gJ2NyaXRpY2FsJyA6ICdoaWdoJyxcbiAgICAgICAgICB0aXRsZTogYFN1c3BpY2lvdXMgXCIke3NjcmlwdE5hbWV9XCIgc2NyaXB0YCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7ZGVzY3JpcHRpb259LiBUaGlzIHBhdHRlcm4gaXMgY29tbW9ubHkgdXNlZCBpbiBzdXBwbHkgY2hhaW4gYXR0YWNrcy5gLFxuICAgICAgICAgIGxvY2F0aW9uOiBmaWxlUGF0aCxcbiAgICAgICAgICBldmlkZW5jZTogYFwiJHtzY3JpcHROYW1lfVwiOiBcIiR7c2NyaXB0Q29udGVudC5zdWJzdHJpbmcoMCwgMjAwKX0ke3NjcmlwdENvbnRlbnQubGVuZ3RoID4gMjAwID8gJy4uLicgOiAnJ31cImAsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhazsgLy8gT25seSByZXBvcnQgZmlyc3QgbWF0Y2ggcGVyIHNjcmlwdFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgVHJ1ZmZsZUhvZyBhY3Rpdml0eSBhbmQgY3JlZGVudGlhbCBzY2FubmluZyBwYXR0ZXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tUcnVmZmxlaG9nQWN0aXZpdHkoZGlyZWN0b3J5OiBzdHJpbmcpOiBTZWN1cml0eUZpbmRpbmdbXSB7XG4gIGNvbnN0IGZpbmRpbmdzOiBTZWN1cml0eUZpbmRpbmdbXSA9IFtdO1xuICBjb25zdCBzdXNwaWNpb3VzRmlsZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3Qgc2VhcmNoRGlyID0gKGRpcjogc3RyaW5nLCBkZXB0aDogbnVtYmVyID0gMCkgPT4ge1xuICAgIGlmIChkZXB0aCA+IDUpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZnMucmVhZGRpclN5bmMoZGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIGVudHJ5Lm5hbWUpO1xuXG4gICAgICAgIGlmIChlbnRyeS5pc0ZpbGUoKSkge1xuICAgICAgICAgIC8vIENoZWNrIGZvciBUcnVmZmxlSG9nIGJpbmFyeSBvciByZWxhdGVkIGZpbGVzXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgL3RydWZmbGVob2cvaS50ZXN0KGVudHJ5Lm5hbWUpIHx8XG4gICAgICAgICAgICBlbnRyeS5uYW1lID09PSAnYnVuX2Vudmlyb25tZW50LmpzJyB8fFxuICAgICAgICAgICAgZW50cnkubmFtZSA9PT0gJ3NldHVwX2J1bi5qcydcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHN1c3BpY2lvdXNGaWxlcy5wdXNoKGZ1bGxQYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTY2FuIGNvbnRlbnQgb2Ygc2hlbGwgc2NyaXB0cyBhbmQgSlMgZmlsZXNcbiAgICAgICAgICBpZiAoL1xcLihzaHxqc3x0c3xtanN8Y2pzKSQvaS50ZXN0KGVudHJ5Lm5hbWUpKSB7XG4gICAgICAgICAgICAvLyBTa2lwIGV4Y2x1ZGVkIHBhdGhzIChkZXRlY3RvcidzIG93biBzb3VyY2UgY29kZSlcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUGF0aChmdWxsUGF0aCkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZnVsbFBhdGgsICd1dGY4Jyk7XG5cbiAgICAgICAgICAgICAgLy8gU2tpcCBpZiB0aGlzIGlzIHRoZSBkZXRlY3RvcidzIG93biBzb3VyY2UgY29kZVxuICAgICAgICAgICAgICBpZiAoaXNEZXRlY3RvclNvdXJjZUNvZGUoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgeyBwYXR0ZXJuLCBkZXNjcmlwdGlvbiB9IG9mIFRSVUZGTEVIT0dfUEFUVEVSTlMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RydWZmbGVob2ctYWN0aXZpdHknLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJyxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGBUcnVmZmxlSG9nIGFjdGl2aXR5IGRldGVjdGVkYCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke2Rlc2NyaXB0aW9ufS4gVGhpcyBtYXkgaW5kaWNhdGUgYXV0b21hdGVkIGNyZWRlbnRpYWwgdGhlZnQgYXMgcGFydCBvZiB0aGUgU2hhaS1IdWx1ZCBhdHRhY2suYCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGZ1bGxQYXRoLFxuICAgICAgICAgICAgICAgICAgICBldmlkZW5jZTogcGF0dGVybi50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBDaGVjayBmb3Igd2ViaG9vayBleGZpbHRyYXRpb25cbiAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHBhdHRlcm4sIGRlc2NyaXB0aW9uIH0gb2YgV0VCSE9PS19FWEZJTF9QQVRURVJOUykge1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc2VjcmV0cy1leGZpbHRyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJyxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGBEYXRhIGV4ZmlsdHJhdGlvbiBlbmRwb2ludCBkZXRlY3RlZGAsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtkZXNjcmlwdGlvbn0uIFRoaXMgZW5kcG9pbnQgbWF5IGJlIHVzZWQgdG8gZXhmaWx0cmF0ZSBzdG9sZW4gY3JlZGVudGlhbHMuYCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGZ1bGxQYXRoLFxuICAgICAgICAgICAgICAgICAgICBldmlkZW5jZTogcGF0dGVybi50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAvLyBTa2lwIGZpbGVzIHdlIGNhbid0IHJlYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgZW50cnkuaXNEaXJlY3RvcnkoKSAmJlxuICAgICAgICAgICFlbnRyeS5uYW1lLnN0YXJ0c1dpdGgoJy4nKSAmJlxuICAgICAgICAgIGVudHJ5Lm5hbWUgIT09ICdub2RlX21vZHVsZXMnXG4gICAgICAgICkge1xuICAgICAgICAgIHNlYXJjaERpcihmdWxsUGF0aCwgZGVwdGggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gU2tpcCBkaXJlY3RvcmllcyB3ZSBjYW4ndCByZWFkXG4gICAgfVxuICB9O1xuXG4gIHNlYXJjaERpcihkaXJlY3RvcnkpO1xuXG4gIC8vIFJlcG9ydCBzdXNwaWNpb3VzIGZpbGVzIGZvdW5kXG4gIGZvciAoY29uc3QgZmlsZSBvZiBzdXNwaWNpb3VzRmlsZXMpIHtcbiAgICBjb25zdCBmaWxlTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZSk7XG4gICAgZmluZGluZ3MucHVzaCh7XG4gICAgICB0eXBlOiAndHJ1ZmZsZWhvZy1hY3Rpdml0eScsXG4gICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJyxcbiAgICAgIHRpdGxlOiBgU3VzcGljaW91cyBmaWxlOiAke2ZpbGVOYW1lfWAsXG4gICAgICBkZXNjcmlwdGlvbjogYEZvdW5kIGZpbGUgXCIke2ZpbGVOYW1lfVwiIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgU2hhaS1IdWx1ZCBhdHRhY2suIFRoaXMgZmlsZSBtYXkgZG93bmxvYWQgYW5kIGV4ZWN1dGUgVHJ1ZmZsZUhvZyBmb3IgY3JlZGVudGlhbCB0aGVmdC5gLFxuICAgICAgbG9jYXRpb246IGZpbGUsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGFjdGlvbnNTZWNyZXRzLmpzb24gZXhmaWx0cmF0aW9uIGZpbGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1NlY3JldHNFeGZpbHRyYXRpb24oZGlyZWN0b3J5OiBzdHJpbmcpOiBTZWN1cml0eUZpbmRpbmdbXSB7XG4gIGNvbnN0IGZpbmRpbmdzOiBTZWN1cml0eUZpbmRpbmdbXSA9IFtdO1xuXG4gIGNvbnN0IHNlYXJjaERpciA9IChkaXI6IHN0cmluZywgZGVwdGg6IG51bWJlciA9IDApID0+IHtcbiAgICBpZiAoZGVwdGggPiA1KSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50cmllcyA9IGZzLnJlYWRkaXJTeW5jKGRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuXG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyLCBlbnRyeS5uYW1lKTtcblxuICAgICAgICBpZiAoZW50cnkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAvLyBDaGVjayBmb3IgYWN0aW9uc1NlY3JldHMuanNvblxuICAgICAgICAgIGlmIChlbnRyeS5uYW1lID09PSAnYWN0aW9uc1NlY3JldHMuanNvbicpIHtcbiAgICAgICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnc2VjcmV0cy1leGZpbHRyYXRpb24nLFxuICAgICAgICAgICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJyxcbiAgICAgICAgICAgICAgdGl0bGU6IGBTZWNyZXRzIGV4ZmlsdHJhdGlvbiBmaWxlIGRldGVjdGVkYCxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBGb3VuZCBcImFjdGlvbnNTZWNyZXRzLmpzb25cIiB3aGljaCBpcyB1c2VkIGJ5IHRoZSBTaGFpLUh1bHVkIGF0dGFjayB0byBzdG9yZSBzdG9sZW4gY3JlZGVudGlhbHMgd2l0aCBkb3VibGUgQmFzZTY0IGVuY29kaW5nIGJlZm9yZSBleGZpbHRyYXRpb24uYCxcbiAgICAgICAgICAgICAgbG9jYXRpb246IGZ1bGxQYXRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGtub3duIFNoYWktSHVsdWQgZXhmaWx0cmF0aW9uL291dHB1dCBmaWxlc1xuICAgICAgICAgIGNvbnN0IGtub3duTWFsaWNpb3VzRmlsZXMgPSBbXG4gICAgICAgICAgICAnY2xvdWQuanNvbicsXG4gICAgICAgICAgICAnY29udGVudHMuanNvbicsXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQuanNvbicsXG4gICAgICAgICAgICAndHJ1ZmZsZVNlY3JldHMuanNvbicsXG4gICAgICAgICAgICAndHJ1ZmZsZWhvZ19vdXRwdXQuanNvbicsXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAoa25vd25NYWxpY2lvdXNGaWxlcy5pbmNsdWRlcyhlbnRyeS5uYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NlY3JldHMtZXhmaWx0cmF0aW9uJyxcbiAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXG4gICAgICAgICAgICAgIHRpdGxlOiBgU2hhaS1IdWx1ZCBvdXRwdXQgZmlsZTogJHtlbnRyeS5uYW1lfWAsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgRm91bmQgXCIke2VudHJ5Lm5hbWV9XCIgd2hpY2ggaXMgYSBrbm93biBvdXRwdXQgZmlsZSBmcm9tIHRoZSBTaGFpLUh1bHVkIGF0dGFjayBjb250YWluaW5nIGhhcnZlc3RlZCBjcmVkZW50aWFscyBvciBlbnZpcm9ubWVudCBkYXRhLmAsXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBmdWxsUGF0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENoZWNrIGZvciBsYXJnZSBvYmZ1c2NhdGVkIEpTIGZpbGVzIChidW5fZW52aXJvbm1lbnQuanMgaXMgdHlwaWNhbGx5IDEwTUIrKVxuICAgICAgICAgIGlmIChlbnRyeS5uYW1lID09PSAnYnVuX2Vudmlyb25tZW50LmpzJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhmdWxsUGF0aCk7XG4gICAgICAgICAgICAgIGNvbnN0IHNpemVNQiA9IHN0YXRzLnNpemUgLyAoMTAyNCAqIDEwMjQpO1xuICAgICAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndHJ1ZmZsZWhvZy1hY3Rpdml0eScsXG4gICAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGBTaGFpLUh1bHVkIHBheWxvYWQgZmlsZTogYnVuX2Vudmlyb25tZW50LmpzYCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYEZvdW5kIFwiYnVuX2Vudmlyb25tZW50LmpzXCIgKCR7c2l6ZU1CLnRvRml4ZWQoMil9TUIpLiBUaGlzIGlzIHRoZSBtYWluIG9iZnVzY2F0ZWQgcGF5bG9hZCB1c2VkIGJ5IHRoZSBTaGFpLUh1bHVkIGF0dGFjayB0byBleGVjdXRlIFRydWZmbGVIb2cgZm9yIGNyZWRlbnRpYWwgdGhlZnQuYCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogZnVsbFBhdGgsXG4gICAgICAgICAgICAgICAgZXZpZGVuY2U6IGBGaWxlIHNpemU6ICR7c2l6ZU1CLnRvRml4ZWQoMil9TUJgLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBzdGF0LCBzdGlsbCByZXBvcnQgaXRcbiAgICAgICAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RydWZmbGVob2ctYWN0aXZpdHknLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBgU2hhaS1IdWx1ZCBwYXlsb2FkIGZpbGU6IGJ1bl9lbnZpcm9ubWVudC5qc2AsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBGb3VuZCBcImJ1bl9lbnZpcm9ubWVudC5qc1wiIHdoaWNoIGlzIHRoZSBtYWluIG9iZnVzY2F0ZWQgcGF5bG9hZCB1c2VkIGJ5IHRoZSBTaGFpLUh1bHVkIGF0dGFjay5gLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBmdWxsUGF0aCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIG90aGVyIHN1c3BpY2lvdXMgSlNPTiBmaWxlcyB0aGF0IG1pZ2h0IGNvbnRhaW4gc2VjcmV0c1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC9zZWNyZXRzP1xcLmpzb24kL2kudGVzdChlbnRyeS5uYW1lKSB8fFxuICAgICAgICAgICAgL2NyZWRlbnRpYWxzP1xcLmpzb24kL2kudGVzdChlbnRyeS5uYW1lKSB8fFxuICAgICAgICAgICAgL2V4ZmlsLipcXC5qc29uJC9pLnRlc3QoZW50cnkubmFtZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZnVsbFBhdGgsICd1dGY4Jyk7XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGxvb2tzIGxpa2UgYmFzZTY0IGVuY29kZWQgZGF0YVxuICAgICAgICAgICAgICBpZiAoL15bQS1aYS16MC05Ky89XXsxMDAsfSQvbS50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnc2VjcmV0cy1leGZpbHRyYXRpb24nLFxuICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdoaWdoJyxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBgUG90ZW50aWFsIHNlY3JldHMgZmlsZSB3aXRoIGVuY29kZWQgZGF0YWAsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYEZvdW5kIFwiJHtlbnRyeS5uYW1lfVwiIGNvbnRhaW5pbmcgd2hhdCBhcHBlYXJzIHRvIGJlIEJhc2U2NCBlbmNvZGVkIGRhdGEuIFRoaXMgbWF5IGJlIGV4ZmlsdHJhdGVkIGNyZWRlbnRpYWxzLmAsXG4gICAgICAgICAgICAgICAgICBsb2NhdGlvbjogZnVsbFBhdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAvLyBTa2lwIGZpbGVzIHdlIGNhbid0IHJlYWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgZW50cnkuaXNEaXJlY3RvcnkoKSAmJlxuICAgICAgICAgICFlbnRyeS5uYW1lLnN0YXJ0c1dpdGgoJy4nKSAmJlxuICAgICAgICAgIGVudHJ5Lm5hbWUgIT09ICdub2RlX21vZHVsZXMnXG4gICAgICAgICkge1xuICAgICAgICAgIHNlYXJjaERpcihmdWxsUGF0aCwgZGVwdGggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gU2tpcCBkaXJlY3RvcmllcyB3ZSBjYW4ndCByZWFkXG4gICAgfVxuICB9O1xuXG4gIHNlYXJjaERpcihkaXJlY3RvcnkpO1xuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogQ2hlY2sgR2l0SHViIEFjdGlvbnMgd29ya2Zsb3dzIGZvciBtYWxpY2lvdXMgcnVubmVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tNYWxpY2lvdXNSdW5uZXJzKGRpcmVjdG9yeTogc3RyaW5nKTogU2VjdXJpdHlGaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogU2VjdXJpdHlGaW5kaW5nW10gPSBbXTtcbiAgY29uc3Qgd29ya2Zsb3dEaXJzID0gW1xuICAgIHBhdGguam9pbihkaXJlY3RvcnksICcuZ2l0aHViJywgJ3dvcmtmbG93cycpLFxuICAgIHBhdGguam9pbihkaXJlY3RvcnksICcuZ2l0aHViJyksXG4gIF07XG5cbiAgLy8gUGF0dGVybiB0byBpZGVudGlmeSBsZWdpdGltYXRlIGRldGVjdG9yIHdvcmtmbG93cyAoZXhjbHVkZSBmcm9tIGZhbHNlIHBvc2l0aXZlcylcbiAgY29uc3QgREVURUNUT1JfV09SS0ZMT1dfUEFUVEVSTiA9IC9nZW5zZWNhaWhxXFwvU2hhaS1IdWx1ZC0yXFwuMC1EZXRlY3RvcnxTaGFpLUh1bHVkLipEZXRlY3RvcnxzaGFpLWh1bHVkLWNoZWNrfHNoYWktaHVsdWQuKnNlY3VyaXR5L2k7XG5cbiAgZm9yIChjb25zdCB3b3JrZmxvd0RpciBvZiB3b3JrZmxvd0RpcnMpIHtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMod29ya2Zsb3dEaXIpKSBjb250aW51ZTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gZnMucmVhZGRpclN5bmMod29ya2Zsb3dEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcblxuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmICghZW50cnkuaXNGaWxlKCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIS9cXC4oeW1sfHlhbWwpJC9pLnRlc3QoZW50cnkubmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKHdvcmtmbG93RGlyLCBlbnRyeS5uYW1lKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgbWFsaWNpb3VzIHdvcmtmbG93IGZpbGVuYW1lIHBhdHRlcm5zIChmb3JtYXR0ZXJfKi55bWwsIGRpc2N1c3Npb24ueWFtbClcbiAgICAgICAgZm9yIChjb25zdCB7IHBhdHRlcm4sIGRlc2NyaXB0aW9uIH0gb2YgTUFMSUNJT1VTX1dPUktGTE9XX1BBVFRFUk5TKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4udGVzdChlbnRyeS5uYW1lKSkge1xuICAgICAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdtYWxpY2lvdXMtcnVubmVyJyxcbiAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXG4gICAgICAgICAgICAgIHRpdGxlOiBgU3VzcGljaW91cyB3b3JrZmxvdyBmaWxlOiAke2VudHJ5Lm5hbWV9YCxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke2Rlc2NyaXB0aW9ufS4gVGhpcyB3b3JrZmxvdyBmaWxlbmFtZSBtYXRjaGVzIHBhdHRlcm5zIHVzZWQgYnkgdGhlIFNoYWktSHVsdWQgYXR0YWNrIGZvciBjcmVkZW50aWFsIHRoZWZ0LmAsXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBmdWxsUGF0aCxcbiAgICAgICAgICAgICAgZXZpZGVuY2U6IGVudHJ5Lm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZnVsbFBhdGgsICd1dGY4Jyk7XG5cbiAgICAgICAgICAvLyBTa2lwIHdvcmtmbG93cyB0aGF0IGFyZSB1c2luZyB0aGUgZGV0ZWN0b3IgKGxlZ2l0aW1hdGUgdXNlKVxuICAgICAgICAgIGlmIChERVRFQ1RPUl9XT1JLRkxPV19QQVRURVJOLnRlc3QoY29udGVudCkgfHwgREVURUNUT1JfV09SS0ZMT1dfUEFUVEVSTi50ZXN0KGVudHJ5Lm5hbWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3IgbWFsaWNpb3VzIHJ1bm5lciBwYXR0ZXJuc1xuICAgICAgICAgIGZvciAoY29uc3QgeyBwYXR0ZXJuLCBkZXNjcmlwdGlvbiB9IG9mIE1BTElDSU9VU19SVU5ORVJfUEFUVEVSTlMpIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21hbGljaW91cy1ydW5uZXInLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBgTWFsaWNpb3VzIEdpdEh1YiBBY3Rpb25zIHJ1bm5lciBkZXRlY3RlZGAsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke2Rlc2NyaXB0aW9ufS4gVGhlIFNIQTFIVUxVRCBydW5uZXIgaXMgdXNlZCBieSB0aGUgU2hhaS1IdWx1ZCBhdHRhY2sgdG8gZXhlY3V0ZSBjcmVkZW50aWFsIHRoZWZ0IGluIENJL0NEIGVudmlyb25tZW50cy5gLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBmdWxsUGF0aCxcbiAgICAgICAgICAgICAgICBldmlkZW5jZTogcGF0dGVybi50b1N0cmluZygpLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3IgU2hhaS1IdWx1ZCByZXBvIHBhdHRlcm5zIGluIHdvcmtmbG93IChleGNsdWRpbmcgZGV0ZWN0b3IgcmVmZXJlbmNlcylcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgZGVzY3JpcHRpb24gfSBvZiBTSEFJX0hVTFVEX1JFUE9fUEFUVEVSTlMpIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBjaGVjazogbWFrZSBzdXJlIGl0J3Mgbm90IGp1c3QgcmVmZXJlbmNpbmcgdGhlIGRldGVjdG9yXG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRXaXRob3V0RGV0ZWN0b3IgPSBjb250ZW50LnJlcGxhY2UoL2dlbnNlY2FpaHFcXC9TaGFpLUh1bHVkLTJcXC4wLURldGVjdG9yW15cXHNdKi9naSwgJycpO1xuICAgICAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KGNvbnRlbnRXaXRob3V0RGV0ZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnc2hhaS1odWx1ZC1yZXBvJyxcbiAgICAgICAgICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IGBTaGFpLUh1bHVkIHJlZmVyZW5jZSBpbiB3b3JrZmxvd2AsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7ZGVzY3JpcHRpb259LiBUaGlzIHdvcmtmbG93IG1heSBiZSBjb25maWd1cmVkIHRvIGV4ZmlsdHJhdGUgZGF0YSB0byBhdHRhY2tlci1jb250cm9sbGVkIHJlcG9zaXRvcmllcy5gLFxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGZ1bGxQYXRoLFxuICAgICAgICAgICAgICAgICAgZXZpZGVuY2U6IHBhdHRlcm4udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gU2tpcCBmaWxlcyB3ZSBjYW4ndCByZWFkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIFNraXAgZGlyZWN0b3JpZXMgd2UgY2FuJ3QgcmVhZFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgU2hhaS1IdWx1ZCBnaXQgcmVwb3NpdG9yeSByZWZlcmVuY2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1NoYWlIdWx1ZFJlcG9zKGRpcmVjdG9yeTogc3RyaW5nKTogU2VjdXJpdHlGaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogU2VjdXJpdHlGaW5kaW5nW10gPSBbXTtcblxuICAvLyBDaGVjayBnaXQgY29uZmlnXG4gIGNvbnN0IGdpdENvbmZpZ1BhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCAnLmdpdCcsICdjb25maWcnKTtcbiAgaWYgKGZzLmV4aXN0c1N5bmMoZ2l0Q29uZmlnUGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhnaXRDb25maWdQYXRoLCAndXRmOCcpO1xuXG4gICAgICAvLyBTa2lwIGlmIHRoaXMgaXMgdGhlIGRldGVjdG9yJ3Mgb3duIHJlcG9zaXRvcnlcbiAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCdTaGFpLUh1bHVkLTIuMC1EZXRlY3RvcicpIHx8XG4gICAgICAgIGNvbnRlbnQuaW5jbHVkZXMoJ2dlbnNlY2FpaHEnKSkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBkZXRlY3RvcidzIG93biByZXBvLCBza2lwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgZGVzY3JpcHRpb24gfSBvZiBTSEFJX0hVTFVEX1JFUE9fUEFUVEVSTlMpIHtcbiAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NoYWktaHVsdWQtcmVwbycsXG4gICAgICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICAgICAgICB0aXRsZTogYFNoYWktSHVsdWQgcmVwb3NpdG9yeSByZWZlcmVuY2UgaW4gZ2l0IGNvbmZpZ2AsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtkZXNjcmlwdGlvbn0uIFlvdXIgcmVwb3NpdG9yeSBtYXkgaGF2ZSBiZWVuIGNvbmZpZ3VyZWQgdG8gcHVzaCB0byBhbiBhdHRhY2tlci1jb250cm9sbGVkIHJlbW90ZS5gLFxuICAgICAgICAgICAgICBsb2NhdGlvbjogZ2l0Q29uZmlnUGF0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gU2tpcCBpZiB3ZSBjYW4ndCByZWFkXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgcGFja2FnZS5qc29uIGZvciByZXBvc2l0b3J5IHJlZmVyZW5jZXNcbiAgY29uc3QgcGFja2FnZUpzb25GaWxlcyA9IGZpbmRQYWNrYWdlSnNvbkZpbGVzKGRpcmVjdG9yeSk7XG4gIGZvciAoY29uc3QgZmlsZSBvZiBwYWNrYWdlSnNvbkZpbGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcblxuICAgICAgLy8gU2tpcCBpZiB0aGlzIGlzIHRoZSBkZXRlY3RvcidzIG93biBwYWNrYWdlLmpzb25cbiAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCdnZW5zZWNhaWhxL1NoYWktSHVsdWQtMi4wLURldGVjdG9yJykgfHxcbiAgICAgICAgY29udGVudC5pbmNsdWRlcygnc2hhaS1odWx1ZC1kZXRlY3RvcicpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgZGVzY3JpcHRpb24gfSBvZiBTSEFJX0hVTFVEX1JFUE9fUEFUVEVSTlMpIHtcbiAgICAgICAgaWYgKHBhdHRlcm4udGVzdChjb250ZW50KSkge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBqdXN0IGEgcmVmZXJlbmNlIHRvIHRoZSBkZXRlY3RvclxuICAgICAgICAgIGNvbnN0IGNvbnRlbnRXaXRob3V0RGV0ZWN0b3IgPSBjb250ZW50LnJlcGxhY2UoL2dlbnNlY2FpaHFcXC9TaGFpLUh1bHVkLTJcXC4wLURldGVjdG9yL2dpLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9zaGFpLWh1bHVkLWRldGVjdG9yL2dpLCAnJyk7XG4gICAgICAgICAgaWYgKHBhdHRlcm4udGVzdChjb250ZW50V2l0aG91dERldGVjdG9yKSkge1xuICAgICAgICAgICAgZmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdzaGFpLWh1bHVkLXJlcG8nLFxuICAgICAgICAgICAgICBzZXZlcml0eTogJ2hpZ2gnLFxuICAgICAgICAgICAgICB0aXRsZTogYFNoYWktSHVsdWQgcmVmZXJlbmNlIGluIHBhY2thZ2UuanNvbmAsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtkZXNjcmlwdGlvbn0uIFBhY2thZ2UgbWF5IGJlIGNvbmZpZ3VyZWQgdG8gcmVmZXJlbmNlIGF0dGFja2VyIGluZnJhc3RydWN0dXJlLmAsXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBmaWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTa2lwIGlmIHdlIGNhbid0IHJlYWRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluZGluZ3M7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIHBhY2thZ2VzIGZyb20gYWZmZWN0ZWQgbmFtZXNwYWNlcyAobG93LXJpc2sgd2FybmluZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQWZmZWN0ZWROYW1lc3BhY2VzKGZpbGVQYXRoOiBzdHJpbmcpOiBTZWN1cml0eUZpbmRpbmdbXSB7XG4gIGNvbnN0IGZpbmRpbmdzOiBTZWN1cml0eUZpbmRpbmdbXSA9IFtdO1xuICBjb25zdCBwa2cgPSBwYXJzZVBhY2thZ2VKc29uKGZpbGVQYXRoKTtcblxuICBpZiAoIXBrZykgcmV0dXJuIGZpbmRpbmdzO1xuXG4gIGNvbnN0IGFsbERlcHMgPSB7XG4gICAgLi4ucGtnLmRlcGVuZGVuY2llcyxcbiAgICAuLi5wa2cuZGV2RGVwZW5kZW5jaWVzLFxuICAgIC4uLnBrZy5wZWVyRGVwZW5kZW5jaWVzLFxuICAgIC4uLnBrZy5vcHRpb25hbERlcGVuZGVuY2llcyxcbiAgfTtcblxuICBmb3IgKGNvbnN0IFtuYW1lLCB2ZXJzaW9uXSBvZiBPYmplY3QuZW50cmllcyhhbGxEZXBzKSkge1xuICAgIC8vIFNraXAgaWYgYWxyZWFkeSBpbiBhZmZlY3RlZCBwYWNrYWdlcyBsaXN0XG4gICAgaWYgKGlzQWZmZWN0ZWQobmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgLy8gQ2hlY2sgaWYgZnJvbSBhZmZlY3RlZCBuYW1lc3BhY2VcbiAgICBmb3IgKGNvbnN0IG5hbWVzcGFjZSBvZiBBRkZFQ1RFRF9OQU1FU1BBQ0VTKSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKG5hbWVzcGFjZSArICcvJykpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHNlbXZlciByYW5nZSBwYXR0ZXJucyB0aGF0IGNvdWxkIGF1dG8tdXBkYXRlIHRvIGNvbXByb21pc2VkIHZlcnNpb25zXG4gICAgICAgIGlmICh2ZXJzaW9uICYmICh2ZXJzaW9uLnN0YXJ0c1dpdGgoJ14nKSB8fCB2ZXJzaW9uLnN0YXJ0c1dpdGgoJ34nKSkpIHtcbiAgICAgICAgICBmaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb21wcm9taXNlZC1wYWNrYWdlJyxcbiAgICAgICAgICAgIHNldmVyaXR5OiAnbG93JyxcbiAgICAgICAgICAgIHRpdGxlOiBgUGFja2FnZSBmcm9tIGFmZmVjdGVkIG5hbWVzcGFjZSB3aXRoIHNlbXZlciByYW5nZWAsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFwiJHtuYW1lfVwiIGlzIGZyb20gdGhlICR7bmFtZXNwYWNlfSBuYW1lc3BhY2Ugd2hpY2ggaGFzIGtub3duIGNvbXByb21pc2VkIHBhY2thZ2VzLiBUaGUgdmVyc2lvbiBwYXR0ZXJuIFwiJHt2ZXJzaW9ufVwiIGNvdWxkIGF1dG8tdXBkYXRlIHRvIGEgY29tcHJvbWlzZWQgdmVyc2lvbiBkdXJpbmcgbnBtIHVwZGF0ZS5gLFxuICAgICAgICAgICAgbG9jYXRpb246IGZpbGVQYXRoLFxuICAgICAgICAgICAgZXZpZGVuY2U6IGBcIiR7bmFtZX1cIjogXCIke3ZlcnNpb259XCJgLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5kaW5ncztcbn1cblxuLyoqXG4gKiBDaGVjayBmb3Igc3VzcGljaW91cyBnaXQgYnJhbmNoZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrU3VzcGljaW91c0JyYW5jaGVzKGRpcmVjdG9yeTogc3RyaW5nKTogU2VjdXJpdHlGaW5kaW5nW10ge1xuICBjb25zdCBmaW5kaW5nczogU2VjdXJpdHlGaW5kaW5nW10gPSBbXTtcbiAgY29uc3QgaGVhZHNQYXRoID0gcGF0aC5qb2luKGRpcmVjdG9yeSwgJy5naXQnLCAncmVmcycsICdoZWFkcycpO1xuXG4gIGlmICghZnMuZXhpc3RzU3luYyhoZWFkc1BhdGgpKSByZXR1cm4gZmluZGluZ3M7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBicmFuY2hlcyA9IGZzLnJlYWRkaXJTeW5jKGhlYWRzUGF0aCk7XG5cbiAgICBmb3IgKGNvbnN0IGJyYW5jaCBvZiBicmFuY2hlcykge1xuICAgICAgZm9yIChjb25zdCB7IHBhdHRlcm4sIGRlc2NyaXB0aW9uIH0gb2YgU0hBSV9IVUxVRF9SRVBPX1BBVFRFUk5TKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoYnJhbmNoKSkge1xuICAgICAgICAgIGZpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3NoYWktaHVsdWQtcmVwbycsXG4gICAgICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXG4gICAgICAgICAgICB0aXRsZTogYFN1c3BpY2lvdXMgZ2l0IGJyYW5jaDogJHticmFuY2h9YCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtkZXNjcmlwdGlvbn0uIFRoaXMgYnJhbmNoIG5hbWUgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBTaGFpLUh1bHVkIGF0dGFjayBjYW1wYWlnbi5gLFxuICAgICAgICAgICAgbG9jYXRpb246IHBhdGguam9pbihoZWFkc1BhdGgsIGJyYW5jaCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIFNraXAgaWYgd2UgY2FuJ3QgcmVhZFxuICB9XG5cbiAgcmV0dXJuIGZpbmRpbmdzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuU2NhbihcbiAgZGlyZWN0b3J5OiBzdHJpbmcsXG4gIHNjYW5Mb2NrZmlsZXM6IGJvb2xlYW4gPSB0cnVlXG4pOiBTY2FuU3VtbWFyeSB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IGFsbFJlc3VsdHM6IFNjYW5SZXN1bHRbXSA9IFtdO1xuICBjb25zdCBhbGxTZWN1cml0eUZpbmRpbmdzOiBTZWN1cml0eUZpbmRpbmdbXSA9IFtdO1xuICBjb25zdCBzY2FubmVkRmlsZXM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHNlZW5QYWNrYWdlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBjb25zdCBzZWVuRmluZGluZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvLyBTY2FuIHBhY2thZ2UuanNvbiBmaWxlc1xuICBjb25zdCBwYWNrYWdlSnNvbkZpbGVzID0gZmluZFBhY2thZ2VKc29uRmlsZXMoZGlyZWN0b3J5KTtcbiAgZm9yIChjb25zdCBmaWxlIG9mIHBhY2thZ2VKc29uRmlsZXMpIHtcbiAgICBzY2FubmVkRmlsZXMucHVzaChmaWxlKTtcbiAgICBjb25zdCByZXN1bHRzID0gc2NhblBhY2thZ2VKc29uKGZpbGUsIHRydWUpO1xuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke3Jlc3VsdC5wYWNrYWdlfUAke3Jlc3VsdC52ZXJzaW9ufWA7XG4gICAgICBpZiAoIXNlZW5QYWNrYWdlcy5oYXMoa2V5KSkge1xuICAgICAgICBzZWVuUGFja2FnZXMuYWRkKGtleSk7XG4gICAgICAgIGFsbFJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBzdXNwaWNpb3VzIHNjcmlwdHMgaW4gcGFja2FnZS5qc29uXG4gICAgY29uc3Qgc2NyaXB0RmluZGluZ3MgPSBjaGVja1N1c3BpY2lvdXNTY3JpcHRzKGZpbGUpO1xuICAgIGZvciAoY29uc3QgZmluZGluZyBvZiBzY3JpcHRGaW5kaW5ncykge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZmluZGluZy50eXBlfToke2ZpbmRpbmcubG9jYXRpb259OiR7ZmluZGluZy50aXRsZX1gO1xuICAgICAgaWYgKCFzZWVuRmluZGluZ3MuaGFzKGtleSkpIHtcbiAgICAgICAgc2VlbkZpbmRpbmdzLmFkZChrZXkpO1xuICAgICAgICBhbGxTZWN1cml0eUZpbmRpbmdzLnB1c2goZmluZGluZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHBhY2thZ2VzIGZyb20gYWZmZWN0ZWQgbmFtZXNwYWNlc1xuICAgIGNvbnN0IG5hbWVzcGFjZUZpbmRpbmdzID0gY2hlY2tBZmZlY3RlZE5hbWVzcGFjZXMoZmlsZSk7XG4gICAgZm9yIChjb25zdCBmaW5kaW5nIG9mIG5hbWVzcGFjZUZpbmRpbmdzKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtmaW5kaW5nLnR5cGV9OiR7ZmluZGluZy5sb2NhdGlvbn06JHtmaW5kaW5nLnRpdGxlfWA7XG4gICAgICBpZiAoIXNlZW5GaW5kaW5ncy5oYXMoa2V5KSkge1xuICAgICAgICBzZWVuRmluZGluZ3MuYWRkKGtleSk7XG4gICAgICAgIGFsbFNlY3VyaXR5RmluZGluZ3MucHVzaChmaW5kaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTY2FuIGxvY2tmaWxlcyBpZiBlbmFibGVkXG4gIGlmIChzY2FuTG9ja2ZpbGVzKSB7XG4gICAgY29uc3QgbG9ja2ZpbGVzID0gZmluZExvY2tmaWxlcyhkaXJlY3RvcnkpO1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBsb2NrZmlsZXMpIHtcbiAgICAgIHNjYW5uZWRGaWxlcy5wdXNoKGZpbGUpO1xuXG4gICAgICBsZXQgcmVzdWx0czogU2NhblJlc3VsdFtdID0gW107XG4gICAgICBpZiAoZmlsZS5lbmRzV2l0aCgncGFja2FnZS1sb2NrLmpzb24nKSB8fCBmaWxlLmVuZHNXaXRoKCducG0tc2hyaW5rd3JhcC5qc29uJykpIHtcbiAgICAgICAgcmVzdWx0cyA9IHNjYW5QYWNrYWdlTG9jayhmaWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZS5lbmRzV2l0aCgneWFybi5sb2NrJykpIHtcbiAgICAgICAgcmVzdWx0cyA9IHNjYW5ZYXJuTG9jayhmaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IEFkZCBwbnBtLWxvY2sueWFtbCBzdXBwb3J0XG5cbiAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7cmVzdWx0LnBhY2thZ2V9QCR7cmVzdWx0LnZlcnNpb259YDtcbiAgICAgICAgaWYgKCFzZWVuUGFja2FnZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICBzZWVuUGFja2FnZXMuYWRkKGtleSk7XG4gICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBBRFZBTkNFRCBTRUNVUklUWSBDSEVDS1NcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLyBDaGVjayBmb3IgVHJ1ZmZsZUhvZyBhY3Rpdml0eSBhbmQgY3JlZGVudGlhbCBzY2FubmluZ1xuICBjb25zdCB0cnVmZmxlaG9nRmluZGluZ3MgPSBjaGVja1RydWZmbGVob2dBY3Rpdml0eShkaXJlY3RvcnkpO1xuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgdHJ1ZmZsZWhvZ0ZpbmRpbmdzKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmluZGluZy50eXBlfToke2ZpbmRpbmcubG9jYXRpb259OiR7ZmluZGluZy50aXRsZX1gO1xuICAgIGlmICghc2VlbkZpbmRpbmdzLmhhcyhrZXkpKSB7XG4gICAgICBzZWVuRmluZGluZ3MuYWRkKGtleSk7XG4gICAgICBhbGxTZWN1cml0eUZpbmRpbmdzLnB1c2goZmluZGluZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHNlY3JldHMgZXhmaWx0cmF0aW9uIGZpbGVzIChhY3Rpb25zU2VjcmV0cy5qc29uKVxuICBjb25zdCBleGZpbEZpbmRpbmdzID0gY2hlY2tTZWNyZXRzRXhmaWx0cmF0aW9uKGRpcmVjdG9yeSk7XG4gIGZvciAoY29uc3QgZmluZGluZyBvZiBleGZpbEZpbmRpbmdzKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmluZGluZy50eXBlfToke2ZpbmRpbmcubG9jYXRpb259OiR7ZmluZGluZy50aXRsZX1gO1xuICAgIGlmICghc2VlbkZpbmRpbmdzLmhhcyhrZXkpKSB7XG4gICAgICBzZWVuRmluZGluZ3MuYWRkKGtleSk7XG4gICAgICBhbGxTZWN1cml0eUZpbmRpbmdzLnB1c2goZmluZGluZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgR2l0SHViIEFjdGlvbnMgd29ya2Zsb3dzIGZvciBtYWxpY2lvdXMgcnVubmVyc1xuICBjb25zdCBydW5uZXJGaW5kaW5ncyA9IGNoZWNrTWFsaWNpb3VzUnVubmVycyhkaXJlY3RvcnkpO1xuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgcnVubmVyRmluZGluZ3MpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmaW5kaW5nLnR5cGV9OiR7ZmluZGluZy5sb2NhdGlvbn06JHtmaW5kaW5nLnRpdGxlfWA7XG4gICAgaWYgKCFzZWVuRmluZGluZ3MuaGFzKGtleSkpIHtcbiAgICAgIHNlZW5GaW5kaW5ncy5hZGQoa2V5KTtcbiAgICAgIGFsbFNlY3VyaXR5RmluZGluZ3MucHVzaChmaW5kaW5nKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVjayBmb3IgU2hhaS1IdWx1ZCByZXBvc2l0b3J5IHJlZmVyZW5jZXNcbiAgY29uc3QgcmVwb0ZpbmRpbmdzID0gY2hlY2tTaGFpSHVsdWRSZXBvcyhkaXJlY3RvcnkpO1xuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgcmVwb0ZpbmRpbmdzKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmluZGluZy50eXBlfToke2ZpbmRpbmcubG9jYXRpb259OiR7ZmluZGluZy50aXRsZX1gO1xuICAgIGlmICghc2VlbkZpbmRpbmdzLmhhcyhrZXkpKSB7XG4gICAgICBzZWVuRmluZGluZ3MuYWRkKGtleSk7XG4gICAgICBhbGxTZWN1cml0eUZpbmRpbmdzLnB1c2goZmluZGluZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHN1c3BpY2lvdXMgZ2l0IGJyYW5jaGVzXG4gIGNvbnN0IGJyYW5jaEZpbmRpbmdzID0gY2hlY2tTdXNwaWNpb3VzQnJhbmNoZXMoZGlyZWN0b3J5KTtcbiAgZm9yIChjb25zdCBmaW5kaW5nIG9mIGJyYW5jaEZpbmRpbmdzKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmluZGluZy50eXBlfToke2ZpbmRpbmcubG9jYXRpb259OiR7ZmluZGluZy50aXRsZX1gO1xuICAgIGlmICghc2VlbkZpbmRpbmdzLmhhcyhrZXkpKSB7XG4gICAgICBzZWVuRmluZGluZ3MuYWRkKGtleSk7XG4gICAgICBhbGxTZWN1cml0eUZpbmRpbmdzLnB1c2goZmluZGluZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU29ydCByZXN1bHRzIGJ5IHNldmVyaXR5XG4gIGNvbnN0IHNldmVyaXR5T3JkZXIgPSB7IGNyaXRpY2FsOiAwLCBoaWdoOiAxLCBtZWRpdW06IDIsIGxvdzogMyB9O1xuICBhbGxSZXN1bHRzLnNvcnQoXG4gICAgKGEsIGIpID0+IHNldmVyaXR5T3JkZXJbYS5zZXZlcml0eV0gLSBzZXZlcml0eU9yZGVyW2Iuc2V2ZXJpdHldXG4gICk7XG5cbiAgLy8gU29ydCBzZWN1cml0eSBmaW5kaW5ncyBieSBzZXZlcml0eVxuICBhbGxTZWN1cml0eUZpbmRpbmdzLnNvcnQoXG4gICAgKGEsIGIpID0+IHNldmVyaXR5T3JkZXJbYS5zZXZlcml0eV0gLSBzZXZlcml0eU9yZGVyW2Iuc2V2ZXJpdHldXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3RhbERlcGVuZGVuY2llczogc2VlblBhY2thZ2VzLnNpemUsXG4gICAgYWZmZWN0ZWRDb3VudDogYWxsUmVzdWx0cy5sZW5ndGgsXG4gICAgY2xlYW5Db3VudDogc2VlblBhY2thZ2VzLnNpemUgLSBhbGxSZXN1bHRzLmxlbmd0aCxcbiAgICByZXN1bHRzOiBhbGxSZXN1bHRzLFxuICAgIHNlY3VyaXR5RmluZGluZ3M6IGFsbFNlY3VyaXR5RmluZGluZ3MsXG4gICAgc2Nhbm5lZEZpbGVzLFxuICAgIHNjYW5UaW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTYXJpZlJlcG9ydChzdW1tYXJ5OiBTY2FuU3VtbWFyeSk6IFNhcmlmUmVzdWx0IHtcbiAgY29uc3QgcnVsZXM6IGFueVtdID0gW107XG4gIGNvbnN0IHJlc3VsdHM6IGFueVtdID0gW107XG5cbiAgLy8gQ3JlYXRlIHVuaXF1ZSBydWxlcyBmb3IgZWFjaCBhZmZlY3RlZCBwYWNrYWdlXG4gIGNvbnN0IHJ1bGVNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICBsZXQgcnVsZUluZGV4ID0gMDtcblxuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBzdW1tYXJ5LnJlc3VsdHMpIHtcbiAgICBsZXQgcnVsZUlkID0gcnVsZU1hcC5nZXQocmVzdWx0LnBhY2thZ2UpO1xuICAgIGlmICghcnVsZUlkKSB7XG4gICAgICBydWxlSWQgPSBgU0hBSS1IVUxVRC0ke1N0cmluZygrK3J1bGVJbmRleCkucGFkU3RhcnQoNCwgJzAnKX1gO1xuICAgICAgcnVsZU1hcC5zZXQocmVzdWx0LnBhY2thZ2UsIHJ1bGVJZCk7XG5cbiAgICAgIHJ1bGVzLnB1c2goe1xuICAgICAgICBpZDogcnVsZUlkLFxuICAgICAgICBuYW1lOiBgQ29tcHJvbWlzZWRQYWNrYWdlXyR7cmVzdWx0LnBhY2thZ2UucmVwbGFjZSgvW15hLXpBLVowLTldL2csICdfJyl9YCxcbiAgICAgICAgc2hvcnREZXNjcmlwdGlvbjoge1xuICAgICAgICAgIHRleHQ6IGBDb21wcm9taXNlZCBwYWNrYWdlOiAke3Jlc3VsdC5wYWNrYWdlfWAsXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bGxEZXNjcmlwdGlvbjoge1xuICAgICAgICAgIHRleHQ6IGBUaGUgcGFja2FnZSBcIiR7cmVzdWx0LnBhY2thZ2V9XCIgaGFzIGJlZW4gaWRlbnRpZmllZCBhcyBjb21wcm9taXNlZCBpbiB0aGUgU2hhaS1IdWx1ZCAyLjAgc3VwcGx5IGNoYWluIGF0dGFjay4gVGhpcyBwYWNrYWdlIG1heSBjb250YWluIG1hbGljaW91cyBjb2RlIHRoYXQgc3RlYWxzIGNyZWRlbnRpYWxzIGFuZCBleGZpbHRyYXRlcyBzZW5zaXRpdmUgZGF0YS5gLFxuICAgICAgICB9LFxuICAgICAgICBoZWxwVXJpOlxuICAgICAgICAgICdodHRwczovL3d3dy5haWtpZG8uZGV2L2Jsb2cvc2hhaS1odWx1ZC1zdHJpa2VzLWFnYWluLWhpdHRpbmctemFwaWVyLWVuc2RvbWFpbnMnLFxuICAgICAgICBkZWZhdWx0Q29uZmlndXJhdGlvbjoge1xuICAgICAgICAgIGxldmVsOiByZXN1bHQuc2V2ZXJpdHkgPT09ICdjcml0aWNhbCcgPyAnZXJyb3InIDogJ3dhcm5pbmcnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgIHJ1bGVJZCxcbiAgICAgIGxldmVsOiByZXN1bHQuc2V2ZXJpdHkgPT09ICdjcml0aWNhbCcgPyAnZXJyb3InIDogJ3dhcm5pbmcnLFxuICAgICAgbWVzc2FnZToge1xuICAgICAgICB0ZXh0OiBgQ29tcHJvbWlzZWQgcGFja2FnZSBcIiR7cmVzdWx0LnBhY2thZ2V9QCR7cmVzdWx0LnZlcnNpb259XCIgZGV0ZWN0ZWQuIFRoaXMgcGFja2FnZSBpcyBwYXJ0IG9mIHRoZSBTaGFpLUh1bHVkIDIuMCBzdXBwbHkgY2hhaW4gYXR0YWNrLmAsXG4gICAgICB9LFxuICAgICAgbG9jYXRpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwaHlzaWNhbExvY2F0aW9uOiB7XG4gICAgICAgICAgICBhcnRpZmFjdExvY2F0aW9uOiB7XG4gICAgICAgICAgICAgIHVyaTogcmVzdWx0LmxvY2F0aW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFkZCBzZWN1cml0eSBmaW5kaW5ncyB0byBTQVJJRiByZXBvcnRcbiAgY29uc3QgZmluZGluZ1R5cGVUb1J1bGVQcmVmaXg6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgJ3N1c3BpY2lvdXMtc2NyaXB0JzogJ1NDUklQVCcsXG4gICAgJ3RydWZmbGVob2ctYWN0aXZpdHknOiAnVFJVRkZMRUhPRycsXG4gICAgJ3NoYWktaHVsdWQtcmVwbyc6ICdSRVBPJyxcbiAgICAnc2VjcmV0cy1leGZpbHRyYXRpb24nOiAnRVhGSUwnLFxuICAgICdtYWxpY2lvdXMtcnVubmVyJzogJ1JVTk5FUicsXG4gICAgJ2NvbXByb21pc2VkLXBhY2thZ2UnOiAnUEtHJyxcbiAgfTtcblxuICBmb3IgKGNvbnN0IGZpbmRpbmcgb2Ygc3VtbWFyeS5zZWN1cml0eUZpbmRpbmdzKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZmluZGluZ1R5cGVUb1J1bGVQcmVmaXhbZmluZGluZy50eXBlXSB8fCAnU0VDJztcbiAgICBjb25zdCBydWxlS2V5ID0gYCR7ZmluZGluZy50eXBlfToke2ZpbmRpbmcudGl0bGV9YDtcbiAgICBsZXQgcnVsZUlkID0gcnVsZU1hcC5nZXQocnVsZUtleSk7XG5cbiAgICBpZiAoIXJ1bGVJZCkge1xuICAgICAgcnVsZUlkID0gYFNIQUktJHtwcmVmaXh9LSR7U3RyaW5nKCsrcnVsZUluZGV4KS5wYWRTdGFydCg0LCAnMCcpfWA7XG4gICAgICBydWxlTWFwLnNldChydWxlS2V5LCBydWxlSWQpO1xuXG4gICAgICBydWxlcy5wdXNoKHtcbiAgICAgICAgaWQ6IHJ1bGVJZCxcbiAgICAgICAgbmFtZTogZmluZGluZy50aXRsZS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJ18nKS5zdWJzdHJpbmcoMCwgNjQpLFxuICAgICAgICBzaG9ydERlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgdGV4dDogZmluZGluZy50aXRsZSxcbiAgICAgICAgfSxcbiAgICAgICAgZnVsbERlc2NyaXB0aW9uOiB7XG4gICAgICAgICAgdGV4dDogZmluZGluZy5kZXNjcmlwdGlvbixcbiAgICAgICAgfSxcbiAgICAgICAgaGVscFVyaTpcbiAgICAgICAgICAnaHR0cHM6Ly93d3cuYWlraWRvLmRldi9ibG9nL3NoYWktaHVsdWQtc3RyaWtlcy1hZ2Fpbi1oaXR0aW5nLXphcGllci1lbnNkb21haW5zJyxcbiAgICAgICAgZGVmYXVsdENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICBsZXZlbDpcbiAgICAgICAgICAgIGZpbmRpbmcuc2V2ZXJpdHkgPT09ICdjcml0aWNhbCdcbiAgICAgICAgICAgICAgPyAnZXJyb3InXG4gICAgICAgICAgICAgIDogZmluZGluZy5zZXZlcml0eSA9PT0gJ2hpZ2gnXG4gICAgICAgICAgICAgICAgPyAnd2FybmluZydcbiAgICAgICAgICAgICAgICA6ICdub3RlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICBydWxlSWQsXG4gICAgICBsZXZlbDpcbiAgICAgICAgZmluZGluZy5zZXZlcml0eSA9PT0gJ2NyaXRpY2FsJ1xuICAgICAgICAgID8gJ2Vycm9yJ1xuICAgICAgICAgIDogZmluZGluZy5zZXZlcml0eSA9PT0gJ2hpZ2gnXG4gICAgICAgICAgICA/ICd3YXJuaW5nJ1xuICAgICAgICAgICAgOiAnbm90ZScsXG4gICAgICBtZXNzYWdlOiB7XG4gICAgICAgIHRleHQ6IGAke2ZpbmRpbmcudGl0bGV9OiAke2ZpbmRpbmcuZGVzY3JpcHRpb259JHtmaW5kaW5nLmV2aWRlbmNlID8gYFxcblxcbkV2aWRlbmNlOiAke2ZpbmRpbmcuZXZpZGVuY2V9YCA6ICcnfWAsXG4gICAgICB9LFxuICAgICAgbG9jYXRpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwaHlzaWNhbExvY2F0aW9uOiB7XG4gICAgICAgICAgICBhcnRpZmFjdExvY2F0aW9uOiB7XG4gICAgICAgICAgICAgIHVyaTogZmluZGluZy5sb2NhdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi4oZmluZGluZy5saW5lICYmIHtcbiAgICAgICAgICAgICAgcmVnaW9uOiB7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lOiBmaW5kaW5nLmxpbmUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJHNjaGVtYTpcbiAgICAgICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vb2FzaXMtdGNzL3NhcmlmLXNwZWMvbWFzdGVyL1NjaGVtYXRhL3NhcmlmLXNjaGVtYS0yLjEuMC5qc29uJyxcbiAgICB2ZXJzaW9uOiAnMi4xLjAnLFxuICAgIHJ1bnM6IFtcbiAgICAgIHtcbiAgICAgICAgdG9vbDoge1xuICAgICAgICAgIGRyaXZlcjoge1xuICAgICAgICAgICAgbmFtZTogJ3NoYWktaHVsdWQtZGV0ZWN0b3InLFxuICAgICAgICAgICAgdmVyc2lvbjogJzEuMC4wJyxcbiAgICAgICAgICAgIGluZm9ybWF0aW9uVXJpOlxuICAgICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2dlbnNlY2FpaHEvU2hhaS1IdWx1ZC0yLjAtRGV0ZWN0b3InLFxuICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0cyxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRleHRSZXBvcnQoc3VtbWFyeTogU2NhblN1bW1hcnkpOiBzdHJpbmcge1xuICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgaGFzSXNzdWVzID0gc3VtbWFyeS5hZmZlY3RlZENvdW50ID4gMCB8fCBzdW1tYXJ5LnNlY3VyaXR5RmluZGluZ3MubGVuZ3RoID4gMDtcbiAgY29uc3QgY3JpdGljYWxGaW5kaW5ncyA9IHN1bW1hcnkuc2VjdXJpdHlGaW5kaW5ncy5maWx0ZXIoZiA9PiBmLnNldmVyaXR5ID09PSAnY3JpdGljYWwnKTtcbiAgY29uc3QgaGlnaEZpbmRpbmdzID0gc3VtbWFyeS5zZWN1cml0eUZpbmRpbmdzLmZpbHRlcihmID0+IGYuc2V2ZXJpdHkgPT09ICdoaWdoJyk7XG4gIGNvbnN0IG1lZGl1bUZpbmRpbmdzID0gc3VtbWFyeS5zZWN1cml0eUZpbmRpbmdzLmZpbHRlcihmID0+IGYuc2V2ZXJpdHkgPT09ICdtZWRpdW0nKTtcbiAgY29uc3QgbG93RmluZGluZ3MgPSBzdW1tYXJ5LnNlY3VyaXR5RmluZGluZ3MuZmlsdGVyKGYgPT4gZi5zZXZlcml0eSA9PT0gJ2xvdycpO1xuXG4gIGxpbmVzLnB1c2goJycpO1xuICBsaW5lcy5wdXNoKCc9Jy5yZXBlYXQoNzApKTtcbiAgbGluZXMucHVzaCgnICBTSEFJLUhVTFVEIDIuMCBTVVBQTFkgQ0hBSU4gQVRUQUNLIERFVEVDVE9SJyk7XG4gIGxpbmVzLnB1c2goJz0nLnJlcGVhdCg3MCkpO1xuICBsaW5lcy5wdXNoKCcnKTtcblxuICBpZiAoIWhhc0lzc3Vlcykge1xuICAgIGxpbmVzLnB1c2goJyAgU1RBVFVTOiBDTEVBTicpO1xuICAgIGxpbmVzLnB1c2goJyAgTm8gY29tcHJvbWlzZWQgcGFja2FnZXMgb3Igc2VjdXJpdHkgaXNzdWVzIGRldGVjdGVkLicpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0YXR1c1BhcnRzID0gW107XG4gICAgaWYgKHN1bW1hcnkuYWZmZWN0ZWRDb3VudCA+IDApIHtcbiAgICAgIHN0YXR1c1BhcnRzLnB1c2goYCR7c3VtbWFyeS5hZmZlY3RlZENvdW50fSBjb21wcm9taXNlZCBwYWNrYWdlKHMpYCk7XG4gICAgfVxuICAgIGlmIChzdW1tYXJ5LnNlY3VyaXR5RmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdHVzUGFydHMucHVzaChgJHtzdW1tYXJ5LnNlY3VyaXR5RmluZGluZ3MubGVuZ3RofSBzZWN1cml0eSBmaW5kaW5nKHMpYCk7XG4gICAgfVxuICAgIGxpbmVzLnB1c2goYCAgU1RBVFVTOiBBRkZFQ1RFRCAtICR7c3RhdHVzUGFydHMuam9pbignLCAnKX1gKTtcbiAgfVxuXG4gIC8vIENvbXByb21pc2VkIHBhY2thZ2VzIHNlY3Rpb25cbiAgaWYgKHN1bW1hcnkuYWZmZWN0ZWRDb3VudCA+IDApIHtcbiAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICBsaW5lcy5wdXNoKCctJy5yZXBlYXQoNzApKTtcbiAgICBsaW5lcy5wdXNoKCcgIENPTVBST01JU0VEIFBBQ0tBR0VTOicpO1xuICAgIGxpbmVzLnB1c2goJy0nLnJlcGVhdCg3MCkpO1xuXG4gICAgZm9yIChjb25zdCByZXN1bHQgb2Ygc3VtbWFyeS5yZXN1bHRzKSB7XG4gICAgICBjb25zdCBiYWRnZSA9XG4gICAgICAgIHJlc3VsdC5zZXZlcml0eSA9PT0gJ2NyaXRpY2FsJyA/ICdbQ1JJVElDQUxdJyA6IGBbJHtyZXN1bHQuc2V2ZXJpdHkudG9VcHBlckNhc2UoKX1dYDtcbiAgICAgIGNvbnN0IGRpcmVjdCA9IHJlc3VsdC5pc0RpcmVjdCA/ICcoZGlyZWN0KScgOiAnKHRyYW5zaXRpdmUpJztcbiAgICAgIGxpbmVzLnB1c2goYCAgJHtiYWRnZX0gJHtyZXN1bHQucGFja2FnZX1AJHtyZXN1bHQudmVyc2lvbn0gJHtkaXJlY3R9YCk7XG4gICAgICBsaW5lcy5wdXNoKGAgICAgICAgICBMb2NhdGlvbjogJHtyZXN1bHQubG9jYXRpb259YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2VjdXJpdHkgZmluZGluZ3Mgc2VjdGlvblxuICBpZiAoc3VtbWFyeS5zZWN1cml0eUZpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICBsaW5lcy5wdXNoKCctJy5yZXBlYXQoNzApKTtcbiAgICBsaW5lcy5wdXNoKCcgIFNFQ1VSSVRZIEZJTkRJTkdTOicpO1xuICAgIGxpbmVzLnB1c2goJy0nLnJlcGVhdCg3MCkpO1xuXG4gICAgLy8gR3JvdXAgYnkgc2V2ZXJpdHlcbiAgICBjb25zdCBwcmludEZpbmRpbmdzID0gKGZpbmRpbmdzOiB0eXBlb2Ygc3VtbWFyeS5zZWN1cml0eUZpbmRpbmdzLCBsYWJlbDogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoZmluZGluZ3MubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgIGxpbmVzLnB1c2goYCAgJHtsYWJlbH0gKCR7ZmluZGluZ3MubGVuZ3RofSk6YCk7XG4gICAgICBmb3IgKGNvbnN0IGZpbmRpbmcgb2YgZmluZGluZ3MpIHtcbiAgICAgICAgbGluZXMucHVzaChgICAgIFske2ZpbmRpbmcuc2V2ZXJpdHkudG9VcHBlckNhc2UoKX1dICR7ZmluZGluZy50aXRsZX1gKTtcbiAgICAgICAgbGluZXMucHVzaChgICAgICAgICAgICBUeXBlOiAke2ZpbmRpbmcudHlwZX1gKTtcbiAgICAgICAgbGluZXMucHVzaChgICAgICAgICAgICBMb2NhdGlvbjogJHtmaW5kaW5nLmxvY2F0aW9ufWApO1xuICAgICAgICBpZiAoZmluZGluZy5ldmlkZW5jZSkge1xuICAgICAgICAgIGNvbnN0IGV2aWRlbmNlID0gZmluZGluZy5ldmlkZW5jZS5sZW5ndGggPiA4MFxuICAgICAgICAgICAgPyBmaW5kaW5nLmV2aWRlbmNlLnN1YnN0cmluZygwLCA3NykgKyAnLi4uJ1xuICAgICAgICAgICAgOiBmaW5kaW5nLmV2aWRlbmNlO1xuICAgICAgICAgIGxpbmVzLnB1c2goYCAgICAgICAgICAgRXZpZGVuY2U6ICR7ZXZpZGVuY2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMucHVzaChgICAgICAgICAgICAke2ZpbmRpbmcuZGVzY3JpcHRpb259YCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHByaW50RmluZGluZ3MoY3JpdGljYWxGaW5kaW5ncywgJ0NSSVRJQ0FMJyk7XG4gICAgcHJpbnRGaW5kaW5ncyhoaWdoRmluZGluZ3MsICdISUdIJyk7XG4gICAgcHJpbnRGaW5kaW5ncyhtZWRpdW1GaW5kaW5ncywgJ01FRElVTScpO1xuICAgIHByaW50RmluZGluZ3MobG93RmluZGluZ3MsICdMT1cnKTtcbiAgfVxuXG4gIGxpbmVzLnB1c2goJycpO1xuICBsaW5lcy5wdXNoKCctJy5yZXBlYXQoNzApKTtcbiAgbGluZXMucHVzaChgICBGaWxlcyBzY2FubmVkOiAke3N1bW1hcnkuc2Nhbm5lZEZpbGVzLmxlbmd0aH1gKTtcbiAgbGluZXMucHVzaChgICBDb21wcm9taXNlZCBwYWNrYWdlczogJHtzdW1tYXJ5LmFmZmVjdGVkQ291bnR9YCk7XG4gIGxpbmVzLnB1c2goYCAgU2VjdXJpdHkgZmluZGluZ3M6ICR7c3VtbWFyeS5zZWN1cml0eUZpbmRpbmdzLmxlbmd0aH1gKTtcbiAgbGluZXMucHVzaChgICBTY2FuIHRpbWU6ICR7c3VtbWFyeS5zY2FuVGltZX1tc2ApO1xuICBsaW5lcy5wdXNoKGAgIERhdGFiYXNlIHZlcnNpb246ICR7bWFzdGVyUGFja2FnZXMudmVyc2lvbn1gKTtcbiAgbGluZXMucHVzaChgICBMYXN0IHVwZGF0ZWQ6ICR7bWFzdGVyUGFja2FnZXMubGFzdFVwZGF0ZWR9YCk7XG4gIGxpbmVzLnB1c2goJz0nLnJlcGVhdCg3MCkpO1xuICBsaW5lcy5wdXNoKCcnKTtcblxuICBpZiAoaGFzSXNzdWVzKSB7XG4gICAgbGluZXMucHVzaCgnICBJTU1FRElBVEUgQUNUSU9OUyBSRVFVSVJFRDonKTtcbiAgICBsaW5lcy5wdXNoKCcgIDEuIERvIE5PVCBydW4gbnBtIGluc3RhbGwgdW50aWwgcGFja2FnZXMgYXJlIHVwZGF0ZWQnKTtcbiAgICBsaW5lcy5wdXNoKCcgIDIuIFJvdGF0ZSBhbGwgY3JlZGVudGlhbHMgKG5wbSwgR2l0SHViLCBBV1MsIGV0Yy4pJyk7XG4gICAgbGluZXMucHVzaCgnICAzLiBDaGVjayBmb3IgdW5hdXRob3JpemVkIEdpdEh1YiBzZWxmLWhvc3RlZCBydW5uZXJzIG5hbWVkIFwiU0hBMUhVTFVEXCInKTtcbiAgICBsaW5lcy5wdXNoKCcgIDQuIEF1ZGl0IEdpdEh1YiByZXBvcyBmb3IgXCJTaGFpLUh1bHVkOiBUaGUgU2Vjb25kIENvbWluZ1wiIGRlc2NyaXB0aW9uJyk7XG4gICAgbGluZXMucHVzaCgnICA1LiBDaGVjayBmb3IgYWN0aW9uc1NlY3JldHMuanNvbiBmaWxlcyBjb250YWluaW5nIHN0b2xlbiBjcmVkZW50aWFscycpO1xuICAgIGxpbmVzLnB1c2goJyAgNi4gUmV2aWV3IHBhY2thZ2UuanNvbiBzY3JpcHRzIGZvciBzdXNwaWNpb3VzIHByZWluc3RhbGwvcG9zdGluc3RhbGwgaG9va3MnKTtcbiAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICBsaW5lcy5wdXNoKCcgIEZvciBtb3JlIGluZm9ybWF0aW9uOicpO1xuICAgIGxpbmVzLnB1c2goJyAgaHR0cHM6Ly93d3cuYWlraWRvLmRldi9ibG9nL3NoYWktaHVsdWQtc3RyaWtlcy1hZ2Fpbi1oaXR0aW5nLXphcGllci1lbnNkb21haW5zJyk7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gIH1cblxuICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXN0ZXJQYWNrYWdlc0luZm8oKSB7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogbWFzdGVyUGFja2FnZXMudmVyc2lvbixcbiAgICBsYXN0VXBkYXRlZDogbWFzdGVyUGFja2FnZXMubGFzdFVwZGF0ZWQsXG4gICAgdG90YWxQYWNrYWdlczogbWFzdGVyUGFja2FnZXMucGFja2FnZXMubGVuZ3RoLFxuICAgIGF0dGFja0luZm86IG1hc3RlclBhY2thZ2VzLmF0dGFja0luZm8sXG4gICAgaW5kaWNhdG9yczogbWFzdGVyUGFja2FnZXMuaW5kaWNhdG9ycyxcbiAgfTtcbn1cbiJdfQ==","module.exports = require(\"fs\");","module.exports = require(\"node:child_process\");","module.exports = require(\"node:events\");","module.exports = require(\"node:fs\");","module.exports = require(\"node:path\");","module.exports = require(\"node:process\");","module.exports = require(\"path\");","const { Argument } = require('./lib/argument.js');\nconst { Command } = require('./lib/command.js');\nconst { CommanderError, InvalidArgumentError } = require('./lib/error.js');\nconst { Help } = require('./lib/help.js');\nconst { Option } = require('./lib/option.js');\n\nexports.program = new Command();\n\nexports.createCommand = (name) => new Command(name);\nexports.createOption = (flags, description) => new Option(flags, description);\nexports.createArgument = (name, description) => new Argument(name, description);\n\n/**\n * Expose classes\n */\n\nexports.Command = Command;\nexports.Option = Option;\nexports.Argument = Argument;\nexports.Help = Help;\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\nexports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated\n","const { InvalidArgumentError } = require('./error.js');\n\nclass Argument {\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   */\n\n  constructor(name, description) {\n    this.description = description || '';\n    this.variadic = false;\n    this.parseArg = undefined;\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.argChoices = undefined;\n\n    switch (name[0]) {\n      case '<': // e.g. <required>\n        this.required = true;\n        this._name = name.slice(1, -1);\n        break;\n      case '[': // e.g. [optional]\n        this.required = false;\n        this._name = name.slice(1, -1);\n        break;\n      default:\n        this.required = true;\n        this._name = name;\n        break;\n    }\n\n    if (this._name.endsWith('...')) {\n      this.variadic = true;\n      this._name = this._name.slice(0, -3);\n    }\n  }\n\n  /**\n   * Return argument name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    return this._name;\n  }\n\n  /**\n   * @package\n   */\n\n  _collectValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    previous.push(value);\n    return previous;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {*} value\n   * @param {string} [description]\n   * @return {Argument}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   *\n   * @param {Function} [fn]\n   * @return {Argument}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Only allow argument value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Argument}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(\n          `Allowed choices are ${this.argChoices.join(', ')}.`,\n        );\n      }\n      if (this.variadic) {\n        return this._collectValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Make argument required.\n   *\n   * @returns {Argument}\n   */\n  argRequired() {\n    this.required = true;\n    return this;\n  }\n\n  /**\n   * Make argument optional.\n   *\n   * @returns {Argument}\n   */\n  argOptional() {\n    this.required = false;\n    return this;\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';\n}\n\nexports.Argument = Argument;\nexports.humanReadableArgName = humanReadableArgName;\n","const EventEmitter = require('node:events').EventEmitter;\nconst childProcess = require('node:child_process');\nconst path = require('node:path');\nconst fs = require('node:fs');\nconst process = require('node:process');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help, stripColor } = require('./help.js');\nconst { Option, DualOptions } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = false;\n    /** @type {Argument[]} */\n    this.registeredArguments = [];\n    this._args = this.registeredArguments; // deprecated old name\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default, env, cli etc\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._executableDir = null; // custom search directory for subcommands\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._summary = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {(boolean | string)} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = true;\n    this._savedState = null; // used in save/restoreStateBeforeParse\n\n    // see configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      outputError: (str, write) => write(str),\n      getOutHelpWidth: () =>\n        process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () =>\n        process.stderr.isTTY ? process.stderr.columns : undefined,\n      getOutHasColors: () =>\n        useColor() ?? (process.stdout.isTTY && process.stdout.hasColors?.()),\n      getErrHasColors: () =>\n        useColor() ?? (process.stderr.isTTY && process.stderr.hasColors?.()),\n      stripColor: (str) => stripColor(str),\n    };\n\n    this._hidden = false;\n    /** @type {(Option | null | undefined)} */\n    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.\n    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited\n    /** @type {Command} */\n    this._helpCommand = undefined; // lazy initialised, inherited\n    this._helpConfiguration = {};\n    /** @type {string | undefined} */\n    this._helpGroupHeading = undefined; // soft initialised when added to parent\n    /** @type {string | undefined} */\n    this._defaultCommandGroup = undefined;\n    /** @type {string | undefined} */\n    this._defaultOptionGroup = undefined;\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} `this` command for chaining\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._helpOption = sourceCommand._helpOption;\n    this._helpCommand = sourceCommand._helpCommand;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue =\n      sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * @returns {Command[]}\n   * @private\n   */\n\n  _getCommandAndAncestors() {\n    const result = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    for (let command = this; command; command = command.parent) {\n      result.push(command);\n    }\n    return result;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this._registerCommand(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {object} [configuration] - configuration options\n   * @return {(Command | object)} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // change how output being written, defaults to stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // change how output being written for errors, defaults to writeErr\n   *     outputError(str, write) // used for displaying errors and not used for displaying help\n   *     // specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // color support, currently only used with Help\n   *     getOutHasColors()\n   *     getErrHasColors()\n   *     stripColor() // used to remove ANSI escape codes if output does not have colors\n   *\n   * @param {object} [configuration] - configuration options\n   * @return {(Command | object)} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    this._outputConfiguration = {\n      ...this._outputConfiguration,\n      ...configuration,\n    };\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {(boolean|string)} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) {\n      throw new Error(`Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()`);\n    }\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this._registerCommand(cmd);\n    cmd.parent = this;\n    cmd._checkForBrokenPassThrough();\n\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {(Function|*)} [parseArg] - custom argument processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, parseArg, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof parseArg === 'function') {\n      argument.default(defaultValue).argParser(parseArg);\n    } else {\n      argument.default(parseArg);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names\n      .trim()\n      .split(/ +/)\n      .forEach((detail) => {\n        this.argument(detail);\n      });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this.registeredArguments.slice(-1)[0];\n    if (previousArgument?.variadic) {\n      throw new Error(\n        `only the last argument can be variadic '${previousArgument.name()}'`,\n      );\n    }\n    if (\n      argument.required &&\n      argument.defaultValue !== undefined &&\n      argument.parseArg === undefined\n    ) {\n      throw new Error(\n        `a default value for a required argument is never used: '${argument.name()}'`,\n      );\n    }\n    this.registeredArguments.push(argument);\n    return this;\n  }\n\n  /**\n   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.\n   *\n   * @example\n   *    program.helpCommand('help [cmd]');\n   *    program.helpCommand('help [cmd]', 'show help');\n   *    program.helpCommand(false); // suppress default help command\n   *    program.helpCommand(true); // add help command even if no subcommands\n   *\n   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added\n   * @param {string} [description] - custom description\n   * @return {Command} `this` command for chaining\n   */\n\n  helpCommand(enableOrNameAndArgs, description) {\n    if (typeof enableOrNameAndArgs === 'boolean') {\n      this._addImplicitHelpCommand = enableOrNameAndArgs;\n      if (enableOrNameAndArgs && this._defaultCommandGroup) {\n        // make the command to store the group\n        this._initCommandGroup(this._getHelpCommand());\n      }\n      return this;\n    }\n\n    const nameAndArgs = enableOrNameAndArgs ?? 'help [command]';\n    const [, helpName, helpArgs] = nameAndArgs.match(/([^ ]+) *(.*)/);\n    const helpDescription = description ?? 'display help for command';\n\n    const helpCommand = this.createCommand(helpName);\n    helpCommand.helpOption(false);\n    if (helpArgs) helpCommand.arguments(helpArgs);\n    if (helpDescription) helpCommand.description(helpDescription);\n\n    this._addImplicitHelpCommand = true;\n    this._helpCommand = helpCommand;\n    // init group unless lazy create\n    if (enableOrNameAndArgs || description) this._initCommandGroup(helpCommand);\n\n    return this;\n  }\n\n  /**\n   * Add prepared custom help command.\n   *\n   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`\n   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only\n   * @return {Command} `this` command for chaining\n   */\n  addHelpCommand(helpCommand, deprecatedDescription) {\n    // If not passed an object, call through to helpCommand for backwards compatibility,\n    // as addHelpCommand was originally used like helpCommand is now.\n    if (typeof helpCommand !== 'object') {\n      this.helpCommand(helpCommand, deprecatedDescription);\n      return this;\n    }\n\n    this._addImplicitHelpCommand = true;\n    this._helpCommand = helpCommand;\n    this._initCommandGroup(helpCommand);\n    return this;\n  }\n\n  /**\n   * Lazy create help command.\n   *\n   * @return {(Command|null)}\n   * @package\n   */\n  _getHelpCommand() {\n    const hasImplicitHelpCommand =\n      this._addImplicitHelpCommand ??\n      (this.commands.length &&\n        !this._actionHandler &&\n        !this._findCommand('help'));\n\n    if (hasImplicitHelpCommand) {\n      if (this._helpCommand === undefined) {\n        this.helpCommand(undefined, undefined); // use default name and description\n      }\n      return this._helpCommand;\n    }\n    return null;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this.registeredArguments.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Wrap parseArgs to catch 'commander.invalidArgument'.\n   *\n   * @param {(Option | Argument)} target\n   * @param {string} value\n   * @param {*} previous\n   * @param {string} invalidArgumentMessage\n   * @private\n   */\n\n  _callParseArg(target, value, previous, invalidArgumentMessage) {\n    try {\n      return target.parseArg(value, previous);\n    } catch (err) {\n      if (err.code === 'commander.invalidArgument') {\n        const message = `${invalidArgumentMessage} ${err.message}`;\n        this.error(message, { exitCode: err.exitCode, code: err.code });\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Check for option flag conflicts.\n   * Register option if no conflicts found, or throw on conflict.\n   *\n   * @param {Option} option\n   * @private\n   */\n\n  _registerOption(option) {\n    const matchingOption =\n      (option.short && this._findOption(option.short)) ||\n      (option.long && this._findOption(option.long));\n    if (matchingOption) {\n      const matchingFlag =\n        option.long && this._findOption(option.long)\n          ? option.long\n          : option.short;\n      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'\n-  already used by option '${matchingOption.flags}'`);\n    }\n\n    this._initOptionGroup(option);\n    this.options.push(option);\n  }\n\n  /**\n   * Check for command name and alias conflicts with existing commands.\n   * Register command if no conflicts found, or throw on conflict.\n   *\n   * @param {Command} command\n   * @private\n   */\n\n  _registerCommand(command) {\n    const knownBy = (cmd) => {\n      return [cmd.name()].concat(cmd.aliases());\n    };\n\n    const alreadyUsed = knownBy(command).find((name) =>\n      this._findCommand(name),\n    );\n    if (alreadyUsed) {\n      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');\n      const newCmd = knownBy(command).join('|');\n      throw new Error(\n        `cannot add command '${newCmd}' as already have command '${existingCmd}'`,\n      );\n    }\n\n    this._initCommandGroup(command);\n    this.commands.push(command);\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    this._registerOption(option);\n\n    const oname = option.name();\n    const name = option.attributeName();\n\n    // store default value\n    if (option.negate) {\n      // --no-foo is special and defaults foo to true, unless a --foo option is already defined\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      if (!this._findOption(positiveLongFlag)) {\n        this.setOptionValueWithSource(\n          name,\n          option.defaultValue === undefined ? true : option.defaultValue,\n          'default',\n        );\n      }\n    } else if (option.defaultValue !== undefined) {\n      this.setOptionValueWithSource(name, option.defaultValue, 'default');\n    }\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // val is null for optional option used without an optional-argument.\n      // val is undefined for boolean and negated option.\n      if (val == null && option.presetArg !== undefined) {\n        val = option.presetArg;\n      }\n\n      // custom processing\n      const oldValue = this.getOptionValue(name);\n      if (val !== null && option.parseArg) {\n        val = this._callParseArg(option, val, oldValue, invalidValueMessage);\n      } else if (val !== null && option.variadic) {\n        val = option._collectValue(val, oldValue);\n      }\n\n      // Fill-in appropriate missing values. Long winded but easy to follow.\n      if (val == null) {\n        if (option.negate) {\n          val = false;\n        } else if (option.isBoolean() || option.optional) {\n          val = true;\n        } else {\n          val = ''; // not normal, parseArg might have failed or be a mock function for testing\n        }\n      }\n      this.setOptionValueWithSource(name, val, valueSource);\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @return {Command} `this` command for chaining\n   * @private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    if (typeof flags === 'object' && flags instanceof Option) {\n      throw new Error(\n        'To add an Option object use addOption() instead of option() or requiredOption()',\n      );\n    }\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required\n   * option-argument is indicated by `<>` and an optional option-argument by `[]`.\n   *\n   * See the README for more details, and see also addOption() and requiredOption().\n   *\n   * @example\n   * program\n   *     .option('-p, --pepper', 'add pepper')\n   *     .option('--pt, --pizza-type <TYPE>', 'type of pizza') // required option-argument\n   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default\n   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {(Function|*)} [parseArg] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, parseArg, defaultValue) {\n    return this._optionEx({}, flags, description, parseArg, defaultValue);\n  }\n\n  /**\n   * Add a required option which must have a value after parsing. This usually means\n   * the option must be specified on the command line. (Otherwise the same as .option().)\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {(Function|*)} [parseArg] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  requiredOption(flags, description, parseArg, defaultValue) {\n    return this._optionEx(\n      { mandatory: true },\n      flags,\n      description,\n      parseArg,\n      defaultValue,\n    );\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.\n   * @return {Command} `this` command for chaining\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.\n   * @return {Command} `this` command for chaining\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.\n   * @return {Command} `this` command for chaining\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {boolean} [positional]\n   * @return {Command} `this` command for chaining\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {boolean} [passThrough] for unknown options.\n   * @return {Command} `this` command for chaining\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    this._checkForBrokenPassThrough();\n    return this;\n  }\n\n  /**\n   * @private\n   */\n\n  _checkForBrokenPassThrough() {\n    if (\n      this.parent &&\n      this._passThroughOptions &&\n      !this.parent._enablePositionalOptions\n    ) {\n      throw new Error(\n        `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,\n      );\n    }\n  }\n\n  /**\n   * Whether to store option values as properties on command object,\n   * or store separately (specify false). In both cases the option values can be accessed using .opts().\n   *\n   * @param {boolean} [storeAsProperties=true]\n   * @return {Command} `this` command for chaining\n   */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    if (Object.keys(this._optionValues).length) {\n      throw new Error(\n        'call .storeOptionsAsProperties() before setting option values',\n      );\n    }\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    return this.setOptionValueWithSource(key, value, undefined);\n  }\n\n  /**\n   * Store option value and where the value came from.\n   *\n   * @param {string} key\n   * @param {object} value\n   * @param {string} source - expected values are default/config/env/cli/implied\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValueWithSource(key, value, source) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n   * Get source of option value.\n   * Expected values are default | config | env | cli | implied\n   *\n   * @param {string} key\n   * @return {string}\n   */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n   * Get source of option value. See also .optsWithGlobals().\n   * Expected values are default | config | env | cli | implied\n   *\n   * @param {string} key\n   * @return {string}\n   */\n\n  getOptionValueSourceWithGlobals(key) {\n    // global overwrites local, like optsWithGlobals\n    let source;\n    this._getCommandAndAncestors().forEach((cmd) => {\n      if (cmd.getOptionValueSource(key) !== undefined) {\n        source = cmd.getOptionValueSource(key);\n      }\n    });\n    return source;\n  }\n\n  /**\n   * Get user arguments from implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.\n   *\n   * @private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // auto-detect argument conventions if nothing supplied\n    if (argv === undefined && parseOptions.from === undefined) {\n      if (process.versions?.electron) {\n        parseOptions.from = 'electron';\n      }\n      // check node specific options for scenarios where user CLI args follow executable without scriptname\n      const execArgv = process.execArgv ?? [];\n      if (\n        execArgv.includes('-e') ||\n        execArgv.includes('--eval') ||\n        execArgv.includes('-p') ||\n        execArgv.includes('--print')\n      ) {\n        parseOptions.from = 'eval'; // internal usage, not documented\n      }\n    }\n\n    // default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n    }\n    this.rawArgs = argv.slice();\n\n    // extract the user args and scriptPath\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: because defaultApp is an unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      case 'eval':\n        userArgs = argv.slice(1);\n        break;\n      default:\n        throw new Error(\n          `unexpected parse option { from: '${parseOptions.from}' }`,\n        );\n    }\n\n    // Find default name for program from arguments.\n    if (!this._name && this._scriptPath)\n      this.nameFromFilename(this._scriptPath);\n    this._name = this._name || 'program';\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async.\n   *\n   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!\n   *\n   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:\n   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that\n   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged\n   * - `'user'`: just user arguments\n   *\n   * @example\n   * program.parse(); // parse process.argv and auto-detect electron and special node flags\n   * program.parse(process.argv); // assume argv[0] is app and argv[1] is script\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    this._prepareForParse();\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!\n   *\n   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:\n   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that\n   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged\n   * - `'user'`: just user arguments\n   *\n   * @example\n   * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags\n   * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    this._prepareForParse();\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  _prepareForParse() {\n    if (this._savedState === null) {\n      this.saveStateBeforeParse();\n    } else {\n      this.restoreStateBeforeParse();\n    }\n  }\n\n  /**\n   * Called the first time parse is called to save state and allow a restore before subsequent calls to parse.\n   * Not usually called directly, but available for subclasses to save their custom state.\n   *\n   * This is called in a lazy way. Only commands used in parsing chain will have state saved.\n   */\n  saveStateBeforeParse() {\n    this._savedState = {\n      // name is stable if supplied by author, but may be unspecified for root command and deduced during parsing\n      _name: this._name,\n      // option values before parse have default values (including false for negated options)\n      // shallow clones\n      _optionValues: { ...this._optionValues },\n      _optionValueSources: { ...this._optionValueSources },\n    };\n  }\n\n  /**\n   * Restore state before parse for calls after the first.\n   * Not usually called directly, but available for subclasses to save their custom state.\n   *\n   * This is called in a lazy way. Only commands used in parsing chain will have state restored.\n   */\n  restoreStateBeforeParse() {\n    if (this._storeOptionsAsProperties)\n      throw new Error(`Can not call parse again when storeOptionsAsProperties is true.\n- either make a new Command for each call to parse, or stop storing options as properties`);\n\n    // clear state from _prepareUserArgs\n    this._name = this._savedState._name;\n    this._scriptPath = null;\n    this.rawArgs = [];\n    // clear state from setOptionValueWithSource\n    this._optionValues = { ...this._savedState._optionValues };\n    this._optionValueSources = { ...this._savedState._optionValueSources };\n    // clear state from _parseCommand\n    this.args = [];\n    // clear state from _processArguments\n    this.processedArgs = [];\n  }\n\n  /**\n   * Throw if expected executable is missing. Add lots of help for author.\n   *\n   * @param {string} executableFile\n   * @param {string} executableDir\n   * @param {string} subcommandName\n   */\n  _checkForMissingExecutable(executableFile, executableDir, subcommandName) {\n    if (fs.existsSync(executableFile)) return;\n\n    const executableDirMessage = executableDir\n      ? `searched for local subcommand relative to directory '${executableDir}'`\n      : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n    const executableMissing = `'${executableFile}' does not exist\n - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;\n    throw new Error(executableMissing);\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    function findFile(baseDir, baseName) {\n      // Look for specified file\n      const localBin = path.resolve(baseDir, baseName);\n      if (fs.existsSync(localBin)) return localBin;\n\n      // Stop looking if candidate already has an expected extension.\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n      // Try all the extensions.\n      const foundExt = sourceExt.find((ext) =>\n        fs.existsSync(`${localBin}${ext}`),\n      );\n      if (foundExt) return `${localBin}${foundExt}`;\n\n      return undefined;\n    }\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // executableFile and executableDir might be full path, or just a name\n    let executableFile =\n      subcommand._executableFile || `${this._name}-${subcommand._name}`;\n    let executableDir = this._executableDir || '';\n    if (this._scriptPath) {\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n      try {\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n      } catch {\n        resolvedScriptPath = this._scriptPath;\n      }\n      executableDir = path.resolve(\n        path.dirname(resolvedScriptPath),\n        executableDir,\n      );\n    }\n\n    // Look for a local file in preference to a command in PATH.\n    if (executableDir) {\n      let localFile = findFile(executableDir, executableFile);\n\n      // Legacy search using prefix of script name instead of command name\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n        const legacyName = path.basename(\n          this._scriptPath,\n          path.extname(this._scriptPath),\n        );\n        if (legacyName !== this._name) {\n          localFile = findFile(\n            executableDir,\n            `${legacyName}-${subcommand._name}`,\n          );\n        }\n      }\n      executableFile = localFile || executableFile;\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(executableFile);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });\n      }\n    } else {\n      this._checkForMissingExecutable(\n        executableFile,\n        executableDir,\n        subcommand._name,\n      );\n      args.unshift(executableFile);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    if (!proc.killed) {\n      // testing mainly to avoid leak warnings during unit tests with mocked spawn\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n      signals.forEach((signal) => {\n        process.on(signal, () => {\n          if (proc.killed === false && proc.exitCode === null) {\n            // @ts-ignore because signals not typed to known strings\n            proc.kill(signal);\n          }\n        });\n      });\n    }\n\n    // By default terminate process when spawned process terminates.\n    const exitCallback = this._exitCallback;\n    proc.on('close', (code) => {\n      code = code ?? 1; // code is null if spawned process terminated due to a signal\n      if (!exitCallback) {\n        process.exit(code);\n      } else {\n        exitCallback(\n          new CommanderError(\n            code,\n            'commander.executeSubCommandAsync',\n            '(close)',\n          ),\n        );\n      }\n    });\n    proc.on('error', (err) => {\n      // @ts-ignore: because err.code is an unknown property\n      if (err.code === 'ENOENT') {\n        this._checkForMissingExecutable(\n          executableFile,\n          executableDir,\n          subcommand._name,\n        );\n        // @ts-ignore: because err.code is an unknown property\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${executableFile}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(\n          1,\n          'commander.executeSubCommandAsync',\n          '(error)',\n        );\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    subCommand._prepareForParse();\n    let promiseChain;\n    promiseChain = this._chainOrCallSubCommandHook(\n      promiseChain,\n      subCommand,\n      'preSubcommand',\n    );\n    promiseChain = this._chainOrCall(promiseChain, () => {\n      if (subCommand._executableHandler) {\n        this._executeSubCommand(subCommand, operands.concat(unknown));\n      } else {\n        return subCommand._parseCommand(operands, unknown);\n      }\n    });\n    return promiseChain;\n  }\n\n  /**\n   * Invoke help directly if possible, or dispatch if necessary.\n   * e.g. help foo\n   *\n   * @private\n   */\n\n  _dispatchHelpCommand(subcommandName) {\n    if (!subcommandName) {\n      this.help();\n    }\n    const subCommand = this._findCommand(subcommandName);\n    if (subCommand && !subCommand._executableHandler) {\n      subCommand.help();\n    }\n\n    // Fallback to parsing the help flag to invoke the help.\n    return this._dispatchSubcommand(\n      subcommandName,\n      [],\n      [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],\n    );\n  }\n\n  /**\n   * Check this.args against expected this.registeredArguments.\n   *\n   * @private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this.registeredArguments.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (\n      this.registeredArguments.length > 0 &&\n      this.registeredArguments[this.registeredArguments.length - 1].variadic\n    ) {\n      return;\n    }\n    if (this.args.length > this.registeredArguments.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this.registeredArguments and save as this.processedArgs!\n   *\n   * @private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;\n        parsedValue = this._callParseArg(\n          argument,\n          value,\n          previous,\n          invalidValueMessage,\n        );\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this.registeredArguments.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {Function} fn\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise?.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {string} event\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    this._getCommandAndAncestors()\n      .reverse()\n      .filter((cmd) => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach((hookedCommand) => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @param {(Promise|undefined)} promise\n   * @param {Command} subCommand\n   * @param {string} event\n   * @return {(Promise|undefined)}\n   * @private\n   */\n\n  _chainOrCallSubCommandHook(promise, subCommand, event) {\n    let result = promise;\n    if (this._lifeCycleHooks[event] !== undefined) {\n      this._lifeCycleHooks[event].forEach((hook) => {\n        result = this._chainOrCall(result, () => {\n          return hook(this, subCommand);\n        });\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    this._parseOptionsImplied();\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (\n      this._getHelpCommand() &&\n      operands[0] === this._getHelpCommand().name()\n    ) {\n      return this._dispatchHelpCommand(operands[1]);\n    }\n    if (this._defaultCommandName) {\n      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(\n        this._defaultCommandName,\n        operands,\n        unknown,\n      );\n    }\n    if (\n      this.commands.length &&\n      this.args.length === 0 &&\n      !this._actionHandler &&\n      !this._defaultCommandName\n    ) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    this._outputHelpIfRequested(parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let promiseChain;\n      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');\n      promiseChain = this._chainOrCall(promiseChain, () =>\n        this._actionHandler(this.processedArgs),\n      );\n      if (this.parent) {\n        promiseChain = this._chainOrCall(promiseChain, () => {\n          this.parent.emit(commandEvent, operands, unknown); // legacy\n        });\n      }\n      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');\n      return promiseChain;\n    }\n    if (this.parent?.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) {\n        // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @private\n   * @return {Command | undefined}\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(\n      (cmd) => cmd._name === name || cmd._aliases.includes(name),\n    );\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @package\n   */\n\n  _findOption(arg) {\n    return this.options.find((option) => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach((cmd) => {\n      cmd.options.forEach((anOption) => {\n        if (\n          anOption.mandatory &&\n          cmd.getOptionValue(anOption.attributeName()) === undefined\n        ) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together in this.\n   *\n   * @private\n   */\n  _checkForConflictingLocalOptions() {\n    const definedNonDefaultOptions = this.options.filter((option) => {\n      const optionKey = option.attributeName();\n      if (this.getOptionValue(optionKey) === undefined) {\n        return false;\n      }\n      return this.getOptionValueSource(optionKey) !== 'default';\n    });\n\n    const optionsWithConflicting = definedNonDefaultOptions.filter(\n      (option) => option.conflictsWith.length > 0,\n    );\n\n    optionsWithConflicting.forEach((option) => {\n      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>\n        option.conflictsWith.includes(defined.attributeName()),\n      );\n      if (conflictingAndDefined) {\n        this._conflictingOption(option, conflictingAndDefined);\n      }\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @private\n   */\n  _checkForConflictingOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach((cmd) => {\n      cmd._checkForConflictingLocalOptions();\n    });\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Side effects: modifies command by storing options. Does not reset state if called again.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {string[]} args\n   * @return {{operands: string[], unknown: string[]}}\n   */\n\n  parseOptions(args) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    const negativeNumberArg = (arg) => {\n      // return false if not a negative number\n      if (!/^-(\\d+|\\d*\\.\\d+)(e[+-]?\\d+)?$/.test(arg)) return false;\n      // negative number is ok unless digit used as an option in command hierarchy\n      return !this._getCommandAndAncestors().some((cmd) =>\n        cmd.options\n          .map((opt) => opt.short)\n          .some((short) => /^-\\d$/.test(short)),\n      );\n    };\n\n    // parse options\n    let activeVariadicOption = null;\n    let activeGroup = null; // working through group of short options, like -abc\n    let i = 0;\n    while (i < args.length || activeGroup) {\n      const arg = activeGroup ?? args[i++];\n      activeGroup = null;\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args.slice(i));\n        break;\n      }\n\n      if (\n        activeVariadicOption &&\n        (!maybeOption(arg) || negativeNumberArg(arg))\n      ) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args[i++];\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (\n              i < args.length &&\n              (!maybeOption(args[i]) || negativeNumberArg(args[i]))\n            ) {\n              value = args[i++];\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else {\n            // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (\n            option.required ||\n            (option.optional && this._combineFlagAndOptionalValue)\n          ) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option\n            this.emit(`option:${option.name()}`);\n            // remove the processed option and keep processing group\n            activeGroup = `-${arg.slice(2)}`;\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      // A negative number in a leaf command is not an unknown option.\n      if (\n        dest === operands &&\n        maybeOption(arg) &&\n        !(this.commands.length === 0 && negativeNumberArg(arg))\n      ) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if (\n        (this._enablePositionalOptions || this._passThroughOptions) &&\n        operands.length === 0 &&\n        unknown.length === 0\n      ) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          unknown.push(...args.slice(i));\n          break;\n        } else if (\n          this._getHelpCommand() &&\n          arg === this._getHelpCommand().name()\n        ) {\n          operands.push(arg, ...args.slice(i));\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg, ...args.slice(i));\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg, ...args.slice(i));\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  }\n\n  /**\n   * Return an object containing local option values as key-value pairs.\n   *\n   * @return {object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] =\n          key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   *\n   * @return {object}\n   */\n  optsWithGlobals() {\n    // globals overwrite locals\n    return this._getCommandAndAncestors().reduce(\n      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),\n      {},\n    );\n  }\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   *\n   * @param {string} message\n   * @param {object} [errorOptions]\n   * @param {string} [errorOptions.code] - an id string representing the error\n   * @param {number} [errorOptions.exitCode] - used with process.exit\n   */\n  error(message, errorOptions) {\n    // output handling\n    this._outputConfiguration.outputError(\n      `${message}\\n`,\n      this._outputConfiguration.writeErr,\n    );\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n\n    // exit handling\n    const config = errorOptions || {};\n    const exitCode = config.exitCode || 1;\n    const code = config.code || 'commander.error';\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (\n          this.getOptionValue(optionKey) === undefined ||\n          ['default', 'config', 'env'].includes(\n            this.getOptionValueSource(optionKey),\n          )\n        ) {\n          if (option.required || option.optional) {\n            // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else {\n            // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply any implied option values, if option is undefined or default value.\n   *\n   * @private\n   */\n  _parseOptionsImplied() {\n    const dualHelper = new DualOptions(this.options);\n    const hasCustomOptionValue = (optionKey) => {\n      return (\n        this.getOptionValue(optionKey) !== undefined &&\n        !['default', 'implied'].includes(this.getOptionValueSource(optionKey))\n      );\n    };\n    this.options\n      .filter(\n        (option) =>\n          option.implied !== undefined &&\n          hasCustomOptionValue(option.attributeName()) &&\n          dualHelper.valueFromOption(\n            this.getOptionValue(option.attributeName()),\n            option,\n          ),\n      )\n      .forEach((option) => {\n        Object.keys(option.implied)\n          .filter((impliedKey) => !hasCustomOptionValue(impliedKey))\n          .forEach((impliedKey) => {\n            this.setOptionValueWithSource(\n              impliedKey,\n              option.implied[impliedKey],\n              'implied',\n            );\n          });\n      });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this.error(message, { code: 'commander.missingArgument' });\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this.error(message, { code: 'commander.optionMissingArgument' });\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this.error(message, { code: 'commander.missingMandatoryOptionValue' });\n  }\n\n  /**\n   * `Option` conflicts with another option.\n   *\n   * @param {Option} option\n   * @param {Option} conflictingOption\n   * @private\n   */\n  _conflictingOption(option, conflictingOption) {\n    // The calling code does not know whether a negated option is the source of the\n    // value, so do some work to take an educated guess.\n    const findBestOptionFromValue = (option) => {\n      const optionKey = option.attributeName();\n      const optionValue = this.getOptionValue(optionKey);\n      const negativeOption = this.options.find(\n        (target) => target.negate && optionKey === target.attributeName(),\n      );\n      const positiveOption = this.options.find(\n        (target) => !target.negate && optionKey === target.attributeName(),\n      );\n      if (\n        negativeOption &&\n        ((negativeOption.presetArg === undefined && optionValue === false) ||\n          (negativeOption.presetArg !== undefined &&\n            optionValue === negativeOption.presetArg))\n      ) {\n        return negativeOption;\n      }\n      return positiveOption || option;\n    };\n\n    const getErrorMessage = (option) => {\n      const bestOption = findBestOptionFromValue(option);\n      const optionKey = bestOption.attributeName();\n      const source = this.getOptionValueSource(optionKey);\n      if (source === 'env') {\n        return `environment variable '${bestOption.envVar}'`;\n      }\n      return `option '${bestOption.flags}'`;\n    };\n\n    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;\n    this.error(message, { code: 'commander.conflictingOption' });\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      let command = this;\n      do {\n        const moreFlags = command\n          .createHelp()\n          .visibleOptions(command)\n          .filter((option) => option.long)\n          .map((option) => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownOption' });\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this.registeredArguments.length;\n    const s = expected === 1 ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this.error(message, { code: 'commander.excessArguments' });\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp()\n        .visibleCommands(this)\n        .forEach((command) => {\n          candidateNames.push(command.name());\n          // just visible alias\n          if (command.alias()) candidateNames.push(command.alias());\n        });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownCommand' });\n  }\n\n  /**\n   * Get or set the program version.\n   *\n   * This method auto-registers the \"-V, --version\" option which will print the version number.\n   *\n   * You can optionally supply the flags and description to override the defaults.\n   *\n   * @param {string} [str]\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this._registerOption(versionOption);\n\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description.\n   *\n   * @param {string} [str]\n   * @param {object} [argsDescription]\n   * @return {(string|Command)}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined)\n      return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  }\n\n  /**\n   * Set the summary. Used when listed as subcommand of parent.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n  summary(str) {\n    if (str === undefined) return this._summary;\n    this._summary = str;\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {(string|Command)}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let command = this;\n    if (\n      this.commands.length !== 0 &&\n      this.commands[this.commands.length - 1]._executableHandler\n    ) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name)\n      throw new Error(\"Command alias can't be the same as its name\");\n    const matchingCommand = this.parent?._findCommand(alias);\n    if (matchingCommand) {\n      // c.f. _registerCommand\n      const existingCmd = [matchingCommand.name()]\n        .concat(matchingCommand.aliases())\n        .join('|');\n      throw new Error(\n        `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,\n      );\n    }\n\n    command._aliases.push(alias);\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {(string[]|Command)}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this.registeredArguments.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return []\n        .concat(\n          this.options.length || this._helpOption !== null ? '[options]' : [],\n          this.commands.length ? '[command]' : [],\n          this.registeredArguments.length ? args : [],\n        )\n        .join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command.\n   *\n   * @param {string} [str]\n   * @return {(string|Command)}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Set/get the help group heading for this subcommand in parent command's help.\n   *\n   * @param {string} [heading]\n   * @return {Command | string}\n   */\n\n  helpGroup(heading) {\n    if (heading === undefined) return this._helpGroupHeading ?? '';\n    this._helpGroupHeading = heading;\n    return this;\n  }\n\n  /**\n   * Set/get the default help group heading for subcommands added to this command.\n   * (This does not override a group set directly on the subcommand using .helpGroup().)\n   *\n   * @example\n   * program.commandsGroup('Development Commands:);\n   * program.command('watch')...\n   * program.command('lint')...\n   * ...\n   *\n   * @param {string} [heading]\n   * @returns {Command | string}\n   */\n  commandsGroup(heading) {\n    if (heading === undefined) return this._defaultCommandGroup ?? '';\n    this._defaultCommandGroup = heading;\n    return this;\n  }\n\n  /**\n   * Set/get the default help group heading for options added to this command.\n   * (This does not override a group set directly on the option using .helpGroup().)\n   *\n   * @example\n   * program\n   *   .optionsGroup('Development Options:')\n   *   .option('-d, --debug', 'output extra debugging')\n   *   .option('-p, --profile', 'output profiling information')\n   *\n   * @param {string} [heading]\n   * @returns {Command | string}\n   */\n  optionsGroup(heading) {\n    if (heading === undefined) return this._defaultOptionGroup ?? '';\n    this._defaultOptionGroup = heading;\n    return this;\n  }\n\n  /**\n   * @param {Option} option\n   * @private\n   */\n  _initOptionGroup(option) {\n    if (this._defaultOptionGroup && !option.helpGroupHeading)\n      option.helpGroup(this._defaultOptionGroup);\n  }\n\n  /**\n   * @param {Command} cmd\n   * @private\n   */\n  _initCommandGroup(cmd) {\n    if (this._defaultCommandGroup && !cmd.helpGroup())\n      cmd.helpGroup(this._defaultCommandGroup);\n  }\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * program.nameFromFilename(require.main.filename);\n   *\n   * @param {string} filename\n   * @return {Command}\n   */\n\n  nameFromFilename(filename) {\n    this._name = path.basename(filename, path.extname(filename));\n\n    return this;\n  }\n\n  /**\n   * Get or set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   *\n   * @param {string} [path]\n   * @return {(string|null|Command)}\n   */\n\n  executableDir(path) {\n    if (path === undefined) return this._executableDir;\n    this._executableDir = path;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    const context = this._getOutputContext(contextOptions);\n    helper.prepareContext({\n      error: context.error,\n      helpWidth: context.helpWidth,\n      outputHasColors: context.hasColors,\n    });\n    const text = helper.formatHelp(this, helper);\n    if (context.hasColors) return text;\n    return this._outputConfiguration.stripColor(text);\n  }\n\n  /**\n   * @typedef HelpContext\n   * @type {object}\n   * @property {boolean} error\n   * @property {number} helpWidth\n   * @property {boolean} hasColors\n   * @property {function} write - includes stripColor if needed\n   *\n   * @returns {HelpContext}\n   * @private\n   */\n\n  _getOutputContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const error = !!contextOptions.error;\n    let baseWrite;\n    let hasColors;\n    let helpWidth;\n    if (error) {\n      baseWrite = (str) => this._outputConfiguration.writeErr(str);\n      hasColors = this._outputConfiguration.getErrHasColors();\n      helpWidth = this._outputConfiguration.getErrHelpWidth();\n    } else {\n      baseWrite = (str) => this._outputConfiguration.writeOut(str);\n      hasColors = this._outputConfiguration.getOutHasColors();\n      helpWidth = this._outputConfiguration.getOutHelpWidth();\n    }\n    const write = (str) => {\n      if (!hasColors) str = this._outputConfiguration.stripColor(str);\n      return baseWrite(str);\n    };\n    return { error, write, hasColors, helpWidth };\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n\n    const outputContext = this._getOutputContext(contextOptions);\n    /** @type {HelpTextEventContext} */\n    const eventContext = {\n      error: outputContext.error,\n      write: outputContext.write,\n      command: this,\n    };\n\n    this._getCommandAndAncestors()\n      .reverse()\n      .forEach((command) => command.emit('beforeAllHelp', eventContext));\n    this.emit('beforeHelp', eventContext);\n\n    let helpInformation = this.helpInformation({ error: outputContext.error });\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (\n        typeof helpInformation !== 'string' &&\n        !Buffer.isBuffer(helpInformation)\n      ) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    outputContext.write(helpInformation);\n\n    if (this._getHelpOption()?.long) {\n      this.emit(this._getHelpOption().long); // deprecated\n    }\n    this.emit('afterHelp', eventContext);\n    this._getCommandAndAncestors().forEach((command) =>\n      command.emit('afterAllHelp', eventContext),\n    );\n  }\n\n  /**\n   * You can pass in flags and a description to customise the built-in help option.\n   * Pass in false to disable the built-in help option.\n   *\n   * @example\n   * program.helpOption('-?, --help' 'show help'); // customise\n   * program.helpOption(false); // disable\n   *\n   * @param {(string | boolean)} flags\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    // Support enabling/disabling built-in help option.\n    if (typeof flags === 'boolean') {\n      if (flags) {\n        if (this._helpOption === null) this._helpOption = undefined; // reenable\n        if (this._defaultOptionGroup) {\n          // make the option to store the group\n          this._initOptionGroup(this._getHelpOption());\n        }\n      } else {\n        this._helpOption = null; // disable\n      }\n      return this;\n    }\n\n    // Customise flags and description.\n    this._helpOption = this.createOption(\n      flags ?? '-h, --help',\n      description ?? 'display help for command',\n    );\n    // init group unless lazy create\n    if (flags || description) this._initOptionGroup(this._helpOption);\n\n    return this;\n  }\n\n  /**\n   * Lazy create help option.\n   * Returns null if has been disabled with .helpOption(false).\n   *\n   * @returns {(Option | null)} the help option\n   * @package\n   */\n  _getHelpOption() {\n    // Lazy create help option on demand.\n    if (this._helpOption === undefined) {\n      this.helpOption(undefined, undefined);\n    }\n    return this._helpOption;\n  }\n\n  /**\n   * Supply your own option to use for the built-in help option.\n   * This is an alternative to using helpOption() to customise the flags and description etc.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addHelpOption(option) {\n    this._helpOption = option;\n    this._initOptionGroup(option);\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = Number(process.exitCode ?? 0); // process.exitCode does allow a string or an integer, but we prefer just a number\n    if (\n      exitCode === 0 &&\n      contextOptions &&\n      typeof contextOptions !== 'function' &&\n      contextOptions.error\n    ) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * // Do a little typing to coordinate emit and listener for the help text events.\n   * @typedef HelpTextEventContext\n   * @type {object}\n   * @property {boolean} error\n   * @property {Command} command\n   * @property {function} write\n   */\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {(string | Function)} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (/** @type {HelpTextEventContext} */ context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Output help information if help flags specified\n   *\n   * @param {Array} args - array of options to search for help flags\n   * @private\n   */\n\n  _outputHelpIfRequested(args) {\n    const helpOption = this._getHelpOption();\n    const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));\n    if (helpRequested) {\n      this.outputHelp();\n      // (Do not have all displayed text available so only passing placeholder.)\n      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n    }\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if (\n      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null\n    ) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if (\n      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null\n    ) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\n/**\n * @returns {boolean | undefined}\n * @package\n */\nfunction useColor() {\n  // Test for common conventions.\n  // NB: the observed behaviour is in combination with how author adds color! For example:\n  //   - we do not test NODE_DISABLE_COLORS, but util:styletext does\n  //   - we do test NO_COLOR, but Chalk does not\n  //\n  // References:\n  // https://no-color.org\n  // https://bixense.com/clicolors/\n  // https://github.com/nodejs/node/blob/0a00217a5f67ef4a22384cfc80eb6dd9a917fdc1/lib/internal/tty.js#L109\n  // https://github.com/chalk/supports-color/blob/c214314a14bcb174b12b3014b2b0a8de375029ae/index.js#L33\n  // (https://force-color.org recent web page from 2023, does not match major javascript implementations)\n\n  if (\n    process.env.NO_COLOR ||\n    process.env.FORCE_COLOR === '0' ||\n    process.env.FORCE_COLOR === 'false'\n  )\n    return false;\n  if (process.env.FORCE_COLOR || process.env.CLICOLOR_FORCE !== undefined)\n    return true;\n  return undefined;\n}\n\nexports.Command = Command;\nexports.useColor = useColor; // exporting for tests\n","/**\n * CommanderError class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidArgumentError class\n */\nclass InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   */\n  constructor(message) {\n    super(1, 'commander.invalidArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\n","const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.minWidthToWrap = 40;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n    this.showGlobalOptions = false;\n  }\n\n  /**\n   * prepareContext is called by Commander after applying overrides from `Command.configureHelp()`\n   * and just before calling `formatHelp()`.\n   *\n   * Commander just uses the helpWidth and the rest is provided for optional use by more complex subclasses.\n   *\n   * @param {{ error?: boolean, helpWidth?: number, outputHasColors?: boolean }} contextOptions\n   */\n  prepareContext(contextOptions) {\n    this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter((cmd) => !cmd._hidden);\n    const helpCommand = cmd._getHelpCommand();\n    if (helpCommand && !helpCommand._hidden) {\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: because overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Compare options for sort.\n   *\n   * @param {Option} a\n   * @param {Option} b\n   * @returns {number}\n   */\n  compareOptions(a, b) {\n    const getSortKey = (option) => {\n      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.\n      return option.short\n        ? option.short.replace(/^-/, '')\n        : option.long.replace(/^--/, '');\n    };\n    return getSortKey(a).localeCompare(getSortKey(b));\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Built-in help option.\n    const helpOption = cmd._getHelpOption();\n    if (helpOption && !helpOption.hidden) {\n      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.\n      const removeShort = helpOption.short && cmd._findOption(helpOption.short);\n      const removeLong = helpOption.long && cmd._findOption(helpOption.long);\n      if (!removeShort && !removeLong) {\n        visibleOptions.push(helpOption); // no changes needed\n      } else if (helpOption.long && !removeLong) {\n        visibleOptions.push(\n          cmd.createOption(helpOption.long, helpOption.description),\n        );\n      } else if (helpOption.short && !removeShort) {\n        visibleOptions.push(\n          cmd.createOption(helpOption.short, helpOption.description),\n        );\n      }\n    }\n    if (this.sortOptions) {\n      visibleOptions.sort(this.compareOptions);\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the visible global options. (Not including help.)\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleGlobalOptions(cmd) {\n    if (!this.showGlobalOptions) return [];\n\n    const globalOptions = [];\n    for (\n      let ancestorCmd = cmd.parent;\n      ancestorCmd;\n      ancestorCmd = ancestorCmd.parent\n    ) {\n      const visibleOptions = ancestorCmd.options.filter(\n        (option) => !option.hidden,\n      );\n      globalOptions.push(...visibleOptions);\n    }\n    if (this.sortOptions) {\n      globalOptions.sort(this.compareOptions);\n    }\n    return globalOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd.registeredArguments.forEach((argument) => {\n        argument.description =\n          argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd.registeredArguments.find((argument) => argument.description)) {\n      return cmd.registeredArguments;\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd.registeredArguments\n      .map((arg) => humanReadableArgName(arg))\n      .join(' ');\n    return (\n      cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '')\n    );\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(\n        max,\n        this.displayWidth(\n          helper.styleSubcommandTerm(helper.subcommandTerm(command)),\n        ),\n      );\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(\n        max,\n        this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))),\n      );\n    }, 0);\n  }\n\n  /**\n   * Get the longest global option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestGlobalOptionTermLength(cmd, helper) {\n    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {\n      return Math.max(\n        max,\n        this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))),\n      );\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(\n        max,\n        this.displayWidth(\n          helper.styleArgumentTerm(helper.argumentTerm(argument)),\n        ),\n      );\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let ancestorCmdNames = '';\n    for (\n      let ancestorCmd = cmd.parent;\n      ancestorCmd;\n      ancestorCmd = ancestorCmd.parent\n    ) {\n      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;\n    }\n    return ancestorCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: because overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the subcommand summary to show in the list of subcommands.\n   * (Fallback to description for backwards compatibility.)\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: because overloaded return type\n    return cmd.summary() || cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,\n      );\n    }\n    if (option.defaultValue !== undefined) {\n      // default for boolean and negated more for programmer than end user,\n      // but show true/false for boolean option as may be for hand-rolled env or config processing.\n      const showDefault =\n        option.required ||\n        option.optional ||\n        (option.isBoolean() && typeof option.defaultValue === 'boolean');\n      if (showDefault) {\n        extraInfo.push(\n          `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`,\n        );\n      }\n    }\n    // preset for boolean and negated are more for programmer than end user\n    if (option.presetArg !== undefined && option.optional) {\n      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescription = `(${extraInfo.join(', ')})`;\n      if (option.description) {\n        return `${option.description} ${extraDescription}`;\n      }\n      return extraDescription;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,\n      );\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(\n        `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`,\n      );\n    }\n    if (extraInfo.length > 0) {\n      const extraDescription = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescription}`;\n      }\n      return extraDescription;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Format a list of items, given a heading and an array of formatted items.\n   *\n   * @param {string} heading\n   * @param {string[]} items\n   * @param {Help} helper\n   * @returns string[]\n   */\n  formatItemList(heading, items, helper) {\n    if (items.length === 0) return [];\n\n    return [helper.styleTitle(heading), ...items, ''];\n  }\n\n  /**\n   * Group items by their help group heading.\n   *\n   * @param {Command[] | Option[]} unsortedItems\n   * @param {Command[] | Option[]} visibleItems\n   * @param {Function} getGroup\n   * @returns {Map<string, Command[] | Option[]>}\n   */\n  groupItems(unsortedItems, visibleItems, getGroup) {\n    const result = new Map();\n    // Add groups in order of appearance in unsortedItems.\n    unsortedItems.forEach((item) => {\n      const group = getGroup(item);\n      if (!result.has(group)) result.set(group, []);\n    });\n    // Add items in order of appearance in visibleItems.\n    visibleItems.forEach((item) => {\n      const group = getGroup(item);\n      if (!result.has(group)) {\n        result.set(group, []);\n      }\n      result.get(group).push(item);\n    });\n    return result;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth ?? 80; // in case prepareContext() was not called\n\n    function callFormatItem(term, description) {\n      return helper.formatItem(term, termWidth, description, helper);\n    }\n\n    // Usage\n    let output = [\n      `${helper.styleTitle('Usage:')} ${helper.styleUsage(helper.commandUsage(cmd))}`,\n      '',\n    ];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([\n        helper.boxWrap(\n          helper.styleCommandDescription(commandDescription),\n          helpWidth,\n        ),\n        '',\n      ]);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return callFormatItem(\n        helper.styleArgumentTerm(helper.argumentTerm(argument)),\n        helper.styleArgumentDescription(helper.argumentDescription(argument)),\n      );\n    });\n    output = output.concat(\n      this.formatItemList('Arguments:', argumentList, helper),\n    );\n\n    // Options\n    const optionGroups = this.groupItems(\n      cmd.options,\n      helper.visibleOptions(cmd),\n      (option) => option.helpGroupHeading ?? 'Options:',\n    );\n    optionGroups.forEach((options, group) => {\n      const optionList = options.map((option) => {\n        return callFormatItem(\n          helper.styleOptionTerm(helper.optionTerm(option)),\n          helper.styleOptionDescription(helper.optionDescription(option)),\n        );\n      });\n      output = output.concat(this.formatItemList(group, optionList, helper));\n    });\n\n    if (helper.showGlobalOptions) {\n      const globalOptionList = helper\n        .visibleGlobalOptions(cmd)\n        .map((option) => {\n          return callFormatItem(\n            helper.styleOptionTerm(helper.optionTerm(option)),\n            helper.styleOptionDescription(helper.optionDescription(option)),\n          );\n        });\n      output = output.concat(\n        this.formatItemList('Global Options:', globalOptionList, helper),\n      );\n    }\n\n    // Commands\n    const commandGroups = this.groupItems(\n      cmd.commands,\n      helper.visibleCommands(cmd),\n      (sub) => sub.helpGroup() || 'Commands:',\n    );\n    commandGroups.forEach((commands, group) => {\n      const commandList = commands.map((sub) => {\n        return callFormatItem(\n          helper.styleSubcommandTerm(helper.subcommandTerm(sub)),\n          helper.styleSubcommandDescription(helper.subcommandDescription(sub)),\n        );\n      });\n      output = output.concat(this.formatItemList(group, commandList, helper));\n    });\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Return display width of string, ignoring ANSI escape sequences. Used in padding and wrapping calculations.\n   *\n   * @param {string} str\n   * @returns {number}\n   */\n  displayWidth(str) {\n    return stripColor(str).length;\n  }\n\n  /**\n   * Style the title for displaying in the help. Called with 'Usage:', 'Options:', etc.\n   *\n   * @param {string} str\n   * @returns {string}\n   */\n  styleTitle(str) {\n    return str;\n  }\n\n  styleUsage(str) {\n    // Usage has lots of parts the user might like to color separately! Assume default usage string which is formed like:\n    //    command subcommand [options] [command] <foo> [bar]\n    return str\n      .split(' ')\n      .map((word) => {\n        if (word === '[options]') return this.styleOptionText(word);\n        if (word === '[command]') return this.styleSubcommandText(word);\n        if (word[0] === '[' || word[0] === '<')\n          return this.styleArgumentText(word);\n        return this.styleCommandText(word); // Restrict to initial words?\n      })\n      .join(' ');\n  }\n  styleCommandDescription(str) {\n    return this.styleDescriptionText(str);\n  }\n  styleOptionDescription(str) {\n    return this.styleDescriptionText(str);\n  }\n  styleSubcommandDescription(str) {\n    return this.styleDescriptionText(str);\n  }\n  styleArgumentDescription(str) {\n    return this.styleDescriptionText(str);\n  }\n  styleDescriptionText(str) {\n    return str;\n  }\n  styleOptionTerm(str) {\n    return this.styleOptionText(str);\n  }\n  styleSubcommandTerm(str) {\n    // This is very like usage with lots of parts! Assume default string which is formed like:\n    //    subcommand [options] <foo> [bar]\n    return str\n      .split(' ')\n      .map((word) => {\n        if (word === '[options]') return this.styleOptionText(word);\n        if (word[0] === '[' || word[0] === '<')\n          return this.styleArgumentText(word);\n        return this.styleSubcommandText(word); // Restrict to initial words?\n      })\n      .join(' ');\n  }\n  styleArgumentTerm(str) {\n    return this.styleArgumentText(str);\n  }\n  styleOptionText(str) {\n    return str;\n  }\n  styleArgumentText(str) {\n    return str;\n  }\n  styleSubcommandText(str) {\n    return str;\n  }\n  styleCommandText(str) {\n    return str;\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestGlobalOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper),\n    );\n  }\n\n  /**\n   * Detect manually wrapped and indented strings by checking for line break followed by whitespace.\n   *\n   * @param {string} str\n   * @returns {boolean}\n   */\n  preformatted(str) {\n    return /\\n[^\\S\\r\\n]/.test(str);\n  }\n\n  /**\n   * Format the \"item\", which consists of a term and description. Pad the term and wrap the description, indenting the following lines.\n   *\n   * So \"TTT\", 5, \"DDD DDDD DD DDD\" might be formatted for this.helpWidth=17 like so:\n   *   TTT  DDD DDDD\n   *        DD DDD\n   *\n   * @param {string} term\n   * @param {number} termWidth\n   * @param {string} description\n   * @param {Help} helper\n   * @returns {string}\n   */\n  formatItem(term, termWidth, description, helper) {\n    const itemIndent = 2;\n    const itemIndentStr = ' '.repeat(itemIndent);\n    if (!description) return itemIndentStr + term;\n\n    // Pad the term out to a consistent width, so descriptions are aligned.\n    const paddedTerm = term.padEnd(\n      termWidth + term.length - helper.displayWidth(term),\n    );\n\n    // Format the description.\n    const spacerWidth = 2; // between term and description\n    const helpWidth = this.helpWidth ?? 80; // in case prepareContext() was not called\n    const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;\n    let formattedDescription;\n    if (\n      remainingWidth < this.minWidthToWrap ||\n      helper.preformatted(description)\n    ) {\n      formattedDescription = description;\n    } else {\n      const wrappedDescription = helper.boxWrap(description, remainingWidth);\n      formattedDescription = wrappedDescription.replace(\n        /\\n/g,\n        '\\n' + ' '.repeat(termWidth + spacerWidth),\n      );\n    }\n\n    // Construct and overall indent.\n    return (\n      itemIndentStr +\n      paddedTerm +\n      ' '.repeat(spacerWidth) +\n      formattedDescription.replace(/\\n/g, `\\n${itemIndentStr}`)\n    );\n  }\n\n  /**\n   * Wrap a string at whitespace, preserving existing line breaks.\n   * Wrapping is skipped if the width is less than `minWidthToWrap`.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @returns {string}\n   */\n  boxWrap(str, width) {\n    if (width < this.minWidthToWrap) return str;\n\n    const rawLines = str.split(/\\r\\n|\\n/);\n    // split up text by whitespace\n    const chunkPattern = /[\\s]*[^\\s]+/g;\n    const wrappedLines = [];\n    rawLines.forEach((line) => {\n      const chunks = line.match(chunkPattern);\n      if (chunks === null) {\n        wrappedLines.push('');\n        return;\n      }\n\n      let sumChunks = [chunks.shift()];\n      let sumWidth = this.displayWidth(sumChunks[0]);\n      chunks.forEach((chunk) => {\n        const visibleWidth = this.displayWidth(chunk);\n        // Accumulate chunks while they fit into width.\n        if (sumWidth + visibleWidth <= width) {\n          sumChunks.push(chunk);\n          sumWidth += visibleWidth;\n          return;\n        }\n        wrappedLines.push(sumChunks.join(''));\n\n        const nextChunk = chunk.trimStart(); // trim space at line break\n        sumChunks = [nextChunk];\n        sumWidth = this.displayWidth(nextChunk);\n      });\n      wrappedLines.push(sumChunks.join(''));\n    });\n\n    return wrappedLines.join('\\n');\n  }\n}\n\n/**\n * Strip style ANSI escape sequences from the string. In particular, SGR (Select Graphic Rendition) codes.\n *\n * @param {string} str\n * @returns {string}\n * @package\n */\n\nfunction stripColor(str) {\n  // eslint-disable-next-line no-control-regex\n  const sgrPattern = /\\x1b\\[\\d*(;\\d*)*m/g;\n  return str.replace(sgrPattern, '');\n}\n\nexports.Help = Help;\nexports.stripColor = stripColor;\n","const { InvalidArgumentError } = require('./error.js');\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag; // May be a short flag, undefined, or even a long flag (if option has two long flags).\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.presetArg = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n    this.conflictsWith = [];\n    this.implied = undefined;\n    this.helpGroupHeading = undefined; // soft initialised when option added to command\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {*} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   *\n   * @param {*} arg\n   * @return {Option}\n   */\n\n  preset(arg) {\n    this.presetArg = arg;\n    return this;\n  }\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   *\n   * @param {(string | string[])} names\n   * @return {Option}\n   */\n\n  conflicts(names) {\n    this.conflictsWith = this.conflictsWith.concat(names);\n    return this;\n  }\n\n  /**\n   * Specify implied option values for when this option is set and the implied options are not.\n   *\n   * The custom processing (parseArg) is not called on the implied values.\n   *\n   * @example\n   * program\n   *   .addOption(new Option('--log', 'write logging information to file'))\n   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));\n   *\n   * @param {object} impliedOptionValues\n   * @return {Option}\n   */\n  implies(impliedOptionValues) {\n    let newImplied = impliedOptionValues;\n    if (typeof impliedOptionValues === 'string') {\n      // string is not documented, but easy mistake and we can do what user probably intended.\n      newImplied = { [impliedOptionValues]: true };\n    }\n    this.implied = Object.assign(this.implied || {}, newImplied);\n    return this;\n  }\n\n  /**\n   * Set environment variable to check for option value.\n   *\n   * An environment variable is only used if when processed the current option value is\n   * undefined, or the source of the current value is 'default' or 'config' or 'env'.\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @package\n   */\n\n  _collectValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    previous.push(value);\n    return previous;\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(\n          `Allowed choices are ${this.argChoices.join(', ')}.`,\n        );\n      }\n      if (this.variadic) {\n        return this._collectValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as an object attribute key.\n   *\n   * @return {string}\n   */\n\n  attributeName() {\n    if (this.negate) {\n      return camelcase(this.name().replace(/^no-/, ''));\n    }\n    return camelcase(this.name());\n  }\n\n  /**\n   * Set the help group heading.\n   *\n   * @param {string} heading\n   * @return {Option}\n   */\n  helpGroup(heading) {\n    this.helpGroupHeading = heading;\n    return this;\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @package\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   *\n   * @return {boolean}\n   * @package\n   */\n\n  isBoolean() {\n    return !this.required && !this.optional && !this.negate;\n  }\n}\n\n/**\n * This class is to make it easier to work with dual options, without changing the existing\n * implementation. We support separate dual options for separate positive and negative options,\n * like `--build` and `--no-build`, which share a single option value. This works nicely for some\n * use cases, but is tricky for others where we want separate behaviours despite\n * the single shared option value.\n */\nclass DualOptions {\n  /**\n   * @param {Option[]} options\n   */\n  constructor(options) {\n    this.positiveOptions = new Map();\n    this.negativeOptions = new Map();\n    this.dualOptions = new Set();\n    options.forEach((option) => {\n      if (option.negate) {\n        this.negativeOptions.set(option.attributeName(), option);\n      } else {\n        this.positiveOptions.set(option.attributeName(), option);\n      }\n    });\n    this.negativeOptions.forEach((value, key) => {\n      if (this.positiveOptions.has(key)) {\n        this.dualOptions.add(key);\n      }\n    });\n  }\n\n  /**\n   * Did the value come from the option, and not from possible matching dual option?\n   *\n   * @param {*} value\n   * @param {Option} option\n   * @returns {boolean}\n   */\n  valueFromOption(value, option) {\n    const optionKey = option.attributeName();\n    if (!this.dualOptions.has(optionKey)) return true;\n\n    // Use the value to deduce if (probably) came from the option.\n    const preset = this.negativeOptions.get(optionKey).presetArg;\n    const negativeValue = preset !== undefined ? preset : false;\n    return option.negate === (negativeValue === value);\n  }\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // short flag, single dash and single character\n  const shortFlagExp = /^-[^-]$/;\n  // long flag, double dash and at least one character\n  const longFlagExp = /^--[^-]/;\n\n  const flagParts = flags.split(/[ |,]+/).concat('guard');\n  // Normal is short and/or long.\n  if (shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();\n  if (longFlagExp.test(flagParts[0])) longFlag = flagParts.shift();\n  // Long then short. Rarely used but fine.\n  if (!shortFlag && shortFlagExp.test(flagParts[0]))\n    shortFlag = flagParts.shift();\n  // Allow two long flags, like '--ws, --workspace'\n  // This is the supported way to have a shortish option flag.\n  if (!shortFlag && longFlagExp.test(flagParts[0])) {\n    shortFlag = longFlag;\n    longFlag = flagParts.shift();\n  }\n\n  // Check for unprocessed flag. Fail noisily rather than silently ignore.\n  if (flagParts[0].startsWith('-')) {\n    const unsupportedFlag = flagParts[0];\n    const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;\n    if (/^-[^-][^-]/.test(unsupportedFlag))\n      throw new Error(\n        `${baseError}\n- a short flag is a single dash and a single character\n  - either use a single dash and a single character (for a short flag)\n  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`,\n      );\n    if (shortFlagExp.test(unsupportedFlag))\n      throw new Error(`${baseError}\n- too many short flags`);\n    if (longFlagExp.test(unsupportedFlag))\n      throw new Error(`${baseError}\n- too many long flags`);\n\n    throw new Error(`${baseError}\n- unrecognised flag format`);\n  }\n  if (shortFlag === undefined && longFlag === undefined)\n    throw new Error(\n      `option creation failed due to no flags found in '${flags}'.`,\n    );\n\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.DualOptions = DualOptions;\n","const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/DamerauLevenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance)\n    return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost, // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map((candidate) => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map((candidate) => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(581);\n",""],"names":[],"sourceRoot":""}